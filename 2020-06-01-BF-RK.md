---
title: 字符串匹配之BF&RK
date: 2020-06-01 12:21:10


categories: 
- 算法
tags: 
- 字符串匹配
- 暴力
- hash
img: /photos/2020.5.30_31/2020_06_01_cover.png
top: false
summary: 字符串匹配暴力和hash优化
mathjax: true

cover: false
# password:
---



# <font face="楷体">字符串匹配算法预告</font>

>- <font face="楷体" color=red size=5>单模式串匹配算法</font>
>>- <b>BF算法</b>（Brute Force 的缩写，也叫暴力匹配算法，朴素匹配算法)
>>>- Brute adj. 蛮干不动脑筋的
>>- <b>RK算法</b>（Rabin-Karp 算法）
>>>- 由它的两位发明者 Rabin 和 Karp 的名字来命名的
>>- <b>BM算法</b>（Boyer-Moore 算法）
>>>- 它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的KMP 算法的3到4倍。
>>- <b>KMP算法</b>
>- <font face="楷体" color=red size=5>多模式串匹配算法</font>
>>- <b>Trie树</b>，（又称前缀树，字典树，单词查找树）
>>>- Trie这个术语来自于retrieval根据词源学, trie的发明者Edward Fredkin把它读作/'tri:/ "tree"。但是 ,其他作者把它读作/'tra1/ "try"。
>>- <b>AC自动机算法</b>（Aho–Corasick算法）是由Alfred V.Aho和Margaret J.Corasick 发明的
>>>- 其实，Trie树跟AC自动机之间的关系，就像单模式串匹配中朴素的串匹配算法，跟KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上罢了。

<b>单模式串匹配的算法</b>
也就是一个串和一个串进行匹配
<b>多模式串匹配的算法</b>
是在一个串中同时查找多个串

## BF算法
一顿暴力，直接贴代码

//指针做输入，const修饰避免改动。
```cpp
int BF(const char *text /*in*/ , const char *pattern /*in*/ )
{
    if((NULL==text)||(NULL==pattern))
    {
		return -2;//非法输入
	}
    
    int pos=0;//位置 
    while('\0'!=text[pos])
    {
    	int i=pos;	//text回溯 
    	int j=0;	//pattern回溯 
    	int sum=0;	//已经匹配字符长度
    	while('\0'!=pattern[j])
        {
        	if(text[i]==pattern[j])
            {
            	++sum;
            	++j;
            	++i; 
            }
            else
            {
            	break;
			}
		}
	 
        if(sum==strlen(pattern))
        {
        	return pos;
		}
        
        ++pos;
    }
    
    return -1;//匹配失败    
}
```

分析BF算法：
>- 时间复杂度$O(n*m)$
>- 空间复杂度$O(1)$

其他补充：
>- 尽管理论上，BF算法的时间复杂度很高，但在实际的开发中，它却是一个比较常用的字符串匹配算法：
>>- 1.实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度大，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。
>>- 2.BF算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug 也容易暴露和修复。<b>在工程中，在满足性能要求的前提下，简单是首选。</b>这也是我们常说的<b>KISS（Keep it Simple and Stupid）设计原则</b>。所以，在实际的软件开发中，绝大部分情况下，BF算法就够用了



## RK算法
<b>联系</b>：RK算法是BF算法的改进，它巧妙借助了我们前面讲过的哈希算法，引入<font face="楷体" color=red size=5>哈希算法</font>，时间复杂度立刻就会降低。
<b>难点</b>：设计一个可以应对各种类型字符的哈希算法并不简单

<b>思路</b>:我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（当然我们需要考虑哈希冲突的问题）。比较哈希值是非常快速的，所以效率提高了。
不过这又<b>引入一个问题</b>：通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率？
<b>哈希算法设计技巧</b>：我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。

<b>没有冲突的哈希</b>：我们只需要比较一下模式串和子串的哈希值
<b>有冲突的哈希</b>：当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。解决方法很简单。当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只
需要再对比一下子串和模式串本身就好了。
当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。

总结：哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间
复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本
身，那时间复杂度就会退化成$O(n*m)$

<b>但一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。</b>

