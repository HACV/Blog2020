---
title: 大端和小端存储
date: 2020-05-29 19:53:47

categories: 
- 编译器底层

tags: 
- 编译器底层
img: /photos/2020.5.29/title.jpg

top: false
summary: 格列夫游记的鸡蛋——大小端之争
mathjax: true

cover: false
# password:
---

## **引子**：
《格列夫游记》一书中讲到，格列佛在小人国中，遇到了这样一件事情：
>  小人国的人纠结于吃鸡蛋的时候，先打破鸡蛋的小端还大端，原来，在这之前所有人都认为,吃鸡蛋前,原始的方法是打破鸡蛋较大的一端。可是当今皇帝的祖父小时候吃鸡蛋,一次按古法打鸡蛋时碰巧将一个手指弄破了,因此他的父亲,当时的皇帝，就下了一道敕令,命令全体臣民吃鸡蛋时打破鸡蛋较小的一端,违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱,其中一个皇帝送了命,另一个丢了王位。关于这一争端,曾出版过几百本大部著作,不过大端派的书一直是受禁的,法律也规定该派的任何人不得做官。

在计算机界，也有一个类似的大端小端之争，但是并没有像小人国那般，原先我们虽然在纠结选大端还是小端存储？但是随着计算机的发展，历史告诉我们，这些都是合理的，但是要在计算机间合理通信或者理解计算机底层的时候，你自己记得转换就好了。


# 大端和小端存储
## 一．概念
大端：指低字节存储在高地址。
小端：指低字节存储在低地址。

**记忆方法：**
<table><td bgcolor=#FFFF FF>小端说：我就是个低低（弟弟）</td></table>

下图描述了——大端存储（低字节存储在内存高地址了）：
 <img src="/photos/2020.5.29/1.png" width="80%">

下图描述了——小端存储（低字节存储在内存低地址了）：：
 <img src="/photos/2020.5.29/2.png" width="80%">

## 二．具体的，大端法和小端法的应用
有的产品用的大端法，有的产品则是小端法。
PS:这个大端和小端并没有严格按照企业界限来区分，因为有的企业，它在之前采用的处理器，可能是大端，但是后面的产品中改变了采用的处理器，可能就采用小端法了。
前沿：许多比较新的微处理器使用双端法，也就是说可以把它们配置成作为大端或者小端的机器运行。

## 三．大端法和小端法导致的问题：
### 1）网络应用程序数据传输
在采用不同大小端存储的机器之间通过网络传送二进制数据时候，会导致采用不同大小端存储方式的数据的字节变成反序。
解决方案：网络应用程序的代码编写，必须遵循已建立的关于字节顺序的规则（第一处：网络传输规定了，网络字节序（它采用的大端））。
第2处，你的机器发送报文前，需要将你的内部表达转换成网络标准。
第3处，你的机器接受报文时候，需要根据你的机器，将网络标准转换为你的内部表示。。

网络字节序
网络上传输的数据都是字节流,对于一个多字节数值，在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;
UDP/TCP/IP协议规定:
把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;

而在发送端发送数据时，发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);
由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;所以说,网络字节序是大端字节序;

比如,我们经过网络发送整型数值0x12345678时,在80x86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数将其转换成大端法存放的数值;

常见CPU的宇节序
大端（big Endian）: PowerPC、IBM、 Sun
小端（little Endian）:x86、DEC
ARM既可以工作在大端模式,也可以工作在小端模式。


### 2）反汇编的时候

<table><tr><td bgcolor=#FFFF FF>（——————未完待续）</td></tr></table>

## 四．如何判别大端和小端
1）我们可以根据C语言中的，联合体来判断，该系统是大端还是小端。
因为，联合体变量总是从低地址存储。

```cpp
#include<stdio.h>
int main()
{
	union test
	{
		int a;
		char c;
	}demo;
	
	demo.a=0x01ffff03;
	printf("%d",demo.c);

	if(0x03==demo.c) 
	{
		printf("这个机器是小端存储！"); 
	}
	else if(0x00==demo.c) 
	{
		printf("这个机器是大端存储！");
	}
	else
	{
		printf("无法判断机器类型！");
	}
	
	return 0;
}
```
显然，
要是小端存储，那么（低字节）0x03在低地址，
要是大端存储，那么（高字节）0x00在低地址。
所以，打印出3就是小端存储。打印出0那就是大端存储。
笔者的电脑是采用的intel的X86CPU，是小端存储。
  <img src="/photos/2020.5.29/3.png" width="80%">






