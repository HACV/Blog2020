<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>底层工具集《转载和修改》</title>
      <link href="/2020/06/27/2020-06-27-Assembly-tools/"/>
      <url>/2020/06/27/2020-06-27-Assembly-tools/</url>
      
        <content type="html"><![CDATA[<h1 id="底层原理研究工具集"><a href="#底层原理研究工具集" class="headerlink" title="底层原理研究工具集"></a>底层原理研究工具集</h1><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><h2 id="一、Windows下"><a href="#一、Windows下" class="headerlink" title="一、Windows下"></a>一、Windows下</h2><h3 id="1）cl-MSVC编译器"><a href="#1）cl-MSVC编译器" class="headerlink" title="1）cl,MSVC编译器"></a>1）cl,MSVC编译器</h3><blockquote><p><code>/c</code>:只编译不链接。<br><code>/Za</code>:禁止语言扩展。<br><code>/link</code>:链接指定的模块或给链接器传递参数。<br><code>/Od</code>:（大写字母O）禁止优化。<br><code>/O2</code>:（大写字母O）以运行速度最快为目标优化。<br><code>/O1</code>:（大写字母O）以最节省空间为目标优化。<br><code>/GR或/GR-</code>:开启或关闭RTTI。<br><code>/Gy</code>:开启函数级别链接。<br><code>/GS或/GS-</code>:开启或关闭。<br><code>/Fa[file]</code>:输出汇编文件。<br><code>/E</code>:只进行预处理并且把结果输出。<br><code>/I</code>:指定头文件包含目录。<br><code>/Zi</code>:启用调试信息。<br><code>/LD</code>:编译产生DLL文件。<br><code>/LDd</code>:编译产生DLL文件(调试版)。<br><code>/MD</code>:与动态 多线程版本运行库MSVCRTLIB链接。<br><code>MDd</code>:与调试版动态多线程版本运行库MSVCRTD.LIB链接。<br><code>/MT</code>:与静态多线程版本运行库LIBCMTLIB链接。<br><code>/MTd</code>:与调试版静态多线程版本运行库LIBCMTD.LIB链接。</p></blockquote><h3 id="2）link，-MSVC链接器"><a href="#2）link，-MSVC链接器" class="headerlink" title="2）link， MSVC链接器"></a>2）link， MSVC链接器</h3><blockquote><p><code>/BASE:address</code>:指定输出文件的基地址。<br><code>/DEBUG</code>:输出调试模式版本。<br><code>/DEF:filename</code>: 指定模块定义文件.DEF。<br><code>/DEFAULTLIB:ibrary</code>:指定默认运行库。<br><code>/DLL</code>: 产生DLL。<br><code>/ENTRY:symbol</code>:指定程序入口。<br><code>/EXPORT:symbol</code>: 指定某个符号为导出符号。<br><code>/HEAP</code>:指定默认堆大小。<br><code>/LIBPATH:dir</code>:指定链接时库搜索路径。<br><code>/MAP[:filename]</code>: 产生链接MAP文件。<br><code>/NODEFAULTLIB[:ibrary]</code>:禁止默认运行库。<br><code>/OUT:filename</code>: 指定输出文件名。<br><code>/RELEASE</code>:以发布版本产生输出文件。<br><code>/STACK</code>: 指定默认栈大小。<br><code>/SUBSYSTEM</code>: 指定子系统。</p></blockquote><h3 id="3）dumpbin-MSVC的COFF-PE文件查看器（反汇编常用）"><a href="#3）dumpbin-MSVC的COFF-PE文件查看器（反汇编常用）" class="headerlink" title="3）dumpbin, MSVC的COFF/PE文件查看器（反汇编常用）"></a>3）dumpbin, MSVC的COFF/PE文件查看器（反汇编常用）</h3><blockquote><p><code>/ALL</code>: 显示所有信息。<br><code>/ARCHIVEMEMBERS</code>: 显示.LIB 文件中所有目标文件列表。<br><code>/DEPENDENTS</code>:显示文件的动态链接依赖关系。<br><code>/DIRECTIVES</code>: 显示链接器指示。<br><code>/DISASM</code>: 显示反汇编。,<br><code>/EXPORTS</code>:显示导出函数表。<br><code>/HEADERS</code>: 显示文件头。<br><code>/IMPORTS</code>: 显示导入函数表。<br><code>/LINENUMBERS</code>:显示行号信息。<br><code>/RELOCATIONS</code>: 显示重定位信息。<br><code>/SECTION:name</code> :显示某个段。<br><code>/SECTION</code>:显示文件概要信息。<br><code>/SYMBOLS</code>: 显示文件符号表。.<br><code>/TLS</code>: 显示线程局部存储TLS信息。</p></blockquote><h2 id="二、Linux下"><a href="#二、Linux下" class="headerlink" title="二、Linux下"></a>二、Linux下</h2><h3 id="1）gcc，GCC编译器"><a href="#1）gcc，GCC编译器" class="headerlink" title="1）gcc，GCC编译器"></a>1）gcc，GCC编译器</h3><blockquote><p><code>-E</code>:只进行预处理并把预处理结果输出。<br><code>-c</code>:只编译不链接。<br><code>-o &lt;filename&gt;</code>:指定输出文件名。.<br><code>-S:</code>输出编译后的汇编代码文件。<br><code>-I</code>;指定头文件路径。<br><code>-e</code> name:<br><code>-e name</code>:指定name为程序入口地址。<br><code>-ffreestanding</code>;编译独立的程序，不会自动链接C运行库、启动文件等。<br><code>-finline-functions,- fno. inline functions</code>:启用/关闭内联函数。<br><code>-g</code>:在编译结果中加入调试信息，-ggdb 就是加入GDB调试器能够识别的格式。<br><code>-L &lt;directory&gt;</code>:指定链接时查找路径，多个路径之间用冒号隔开。<br><code>-nostarfiles</code>:不要链接启动文件，比如crtbegin.o、crtend.o.<br><code>-nostdlib</code>:不要链接标准库文件，主要是C运行库。<br><code>-O0</code>:关闭所有优化选项。（前面是大写字母O，后面是数字0）<br><code>-shared</code>:产生共享对象文件。<br><code>-static</code>:使用静态链接。<br><code>-Wall</code>:对源代码中的多数编译警告进行启用。<br><code>-fPIC</code>:使用地址无关代码模式进行编译。<br><code>-PIE</code>:使用地址无关代码模式编译可执行文件。<br><code>-XLinker &lt;option&gt;</code>:把option传递给链接器。<br><code>-Wl &lt;option&gt;</code>:把option传递给链接器，与上面的选项类似。<br><code>-fomit-frame-pointer</code>:禁止使用EBP作为函数帧指针。<br><code>-fno-buitin</code>:禁止GCC编译器内置函数。<br><code>-fno-stack-    protector</code>:是指关闭堆栈保护功能。<br><code>-ffunctionsections</code>:将每个函数编译到独立的代码段。<br><code>-fdata-sections</code>:将全局/静态变量编译到独立的数据段。</p></blockquote><h3 id="2）ld，GNU链接器（Linker）"><a href="#2）ld，GNU链接器（Linker）" class="headerlink" title="2）ld，GNU链接器（Linker）"></a>2）ld，GNU链接器（Linker）</h3><blockquote><p><code>-static</code>:静态链接。<br><code>-I&lt;libname&gt;</code>:指定链接某个库。<br><code>-e name</code>:指定name为程序尺口。<br><code>-r</code>: 合并目标文件，不进行最终链接。<br><code>-L &lt;directory&gt;</code>:指定链接时查找路径，多个路径之间用冒号隔开。<br><code>-M</code>;将链接时的符号和地址输出成-个映射文件。<br><code>-o</code>:指定输出文件名。<br><code>-s</code>:清除输出文件中的符号信息。<br><code>-S</code>:清除输出文件中的调试信息。<br><code>-T &lt;scriptfile&gt;</code>:指定链接脚本文件。<br><code>-version-script &lt;file&gt;</code>:指定符号版本脚本文件。<br><code>-soname &lt;name&gt;</code>:指定输出共享库的SONAME.<br><code>-export dynamic</code>:将全局符号全部导出。<br><code>-verbose</code>:链接时输出详细信息。<br><code>-rpath &lt;path&gt;</code>:指定链接时库查找路径。</p></blockquote><h3 id="3）objdump-GNU目标文件可执行文件查看器（反汇编常用）"><a href="#3）objdump-GNU目标文件可执行文件查看器（反汇编常用）" class="headerlink" title="3）objdump, GNU目标文件可执行文件查看器（反汇编常用）"></a>3）objdump, GNU目标文件可执行文件查看器（反汇编常用）</h3><blockquote><p><code>-a</code>:列举.a文件中所有的目标文件。.<br><code>-b</code> bfdname:指定BFD名。<br><code>-C</code>:对于C++符号名进行反修饰(Demangle).<br><code>-g</code>:显示调试信息。<br><code>-d</code>:对包含机器指令的段进行反汇编。<br><code>-D</code>:对所有的段进行反汇编。<br><code>-f</code>:显示目标文件文件头。<br><code>-h</code>: 显示段表。<br><code>|</code>:显示行 号信息。<br><code>-p</code>:显示专有头部信息，具体内容取决于文件格式。<br><code>-r</code>:显示重定位信息。<br><code>-R</code>:显示动态链接重定位信息。<br><code>-S</code>:.显示文件所有内容。<br><code>-S</code>:显示源代码和反汇编代码(包含-d参数)。<br><code>-W</code>:显示文件中包含有DWARF调试信息格式的段。<br><code>-t</code>:显示文件中的符号表。<br><code>-T</code>:显示动态链接符号表。<br><code>-X</code>：显示文件的所有文件头。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 汇编（Assembly） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左移和右移</title>
      <link href="/2020/06/26/2020-06-26-Displacement/"/>
      <url>/2020/06/26/2020-06-26-Displacement/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算之左移和右移"><a href="#位运算之左移和右移" class="headerlink" title="位运算之左移和右移"></a>位运算之左移和右移</h1><h2 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a>一、用途</h2><p>1）获得int型最大值<br>这样的话在编程的时候就算不带书也能很准确的得知int等的数字大小。<br>其实就是不想记忆具体范围。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">getMaxInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2147483647， 由于优先级关系，括号不可省略</span><span class="token punctuation">}</span></code></pre><p>解释：整型int占用4个字节（即32位）<br>所以可以表示2<sup>32</sup>个数字，int有正负和0；<br>所以表示的数字范围是    -2<sup>31</sup>—（2<sup>31</sup>-1）<br>所以是1（二进制为 00000000 00000000 00000000 00000001）<br>移位31位，然后变成了2<sup>31</sup>  （二进制为 10000000 00000000 00000000 00000000）<br> 但是0占掉了一个数字，所以还要减去1，才得到最大的int的数值。<br>（二进制为 01111111 11111111 11111111 11111111）<br>注意：<br>我在测试的时候，在devC++和VS2017中编译这个，都显示了warm<br><code>[Warning] integer overflow in expression [-Woverflow]</code><br>但是都最终还是显示了结果：</p><p>原因：<br>1.最高位的进位在计算机中被舍去，因为没有位去存储它<br>2.在计算机中似乎<strong>只检测有符号数的溢出</strong>（<strong>这就和那本书《C陷阱与缺陷》上说的一样，我们不认为无符号整数有溢出。。。</strong>），在编译器中会显示warm，但是它不给你处理，还是会让你运行。（这是正常的，正是因为这样，所以C语言才这么自由，它认为这些你能够自己解决）它还是一样的用加法器和补码器进行有符号数和无符号数的加法和减法。<br>补码器真的就是由这样的电路组成<br>1.如果是有符号数的取补码，符号位不变，后面的诸位取反然后末尾加1<br>2.无符号数的取补码</p><h2 id="二、右移——注意点"><a href="#二、右移——注意点" class="headerlink" title="二、右移——注意点"></a>二、右移——注意点</h2><p>比如，求int类型数据中bit中1点个数。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">++</span>sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        n<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>看上去，蛮好的，但是其实不然<br>因为，我们需要注意右移的一个注意点。<br><font style="background: yellow">对于<strong>有符号数</strong>的<strong>右移</strong>，它会用符号位来补全。</font></p><p>这样测试</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">++</span>sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"loop\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//测试</span>        n<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//发现，一直输出loop</span><span class="token comment" spellcheck="true">//因为-1的二进制全是1，符号位也是1。一直右移，还是把1补进来。</span></code></pre><p>此外，用1，这样的有符号数测试，就会发现，得出了1，因为他的符号位是0，到时候补的还是0</p><p><font style="background: yellow">改进：（用无符号数来右移，就能解决这种右移可能导致的bug）</font></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> temp<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//改进</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">++</span>sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用-1，测试是32</span></code></pre><h2 id="三、C语言中数据表示的杂谈"><a href="#三、C语言中数据表示的杂谈" class="headerlink" title="三、C语言中数据表示的杂谈"></a>三、C语言中数据表示的杂谈</h2><p><font style="background: yellow">C语言中变量<strong>默认为有符号</strong>的类型</font><br>unsigned关键字声明变量为无符号类型<br>C语言中<strong>只有整数类型</strong>能够声明unsigned变量</p><p>1）有符号数的表示法<br>在计算机内部用补码表示有符号数<br>正数的补码为正数本身<br>负数的补码为负数的绝对值各位取反后加1<br>2）无符号数的表示法<br>在计算机内部用原码表示无符号数<br><strong>无符号数默认为正数</strong><br>无符号数没有符号位<br>对于固定长度的无符号数            有用！</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//其实，获取C语言中数据范围，还可以查看这些宏，但是不同编译器可能实现不同？忘记查了。</span>MAX_VALUE <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">--</span><span class="token operator">></span> MIN_VALUEMIN_VALUE <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">--</span><span class="token operator">></span> MAX_VALUE</code></pre><p>计算机中，当确定为有符号数运算时，符号数一律用补码表示，运算时符号位和数字位一起参加运算。<br>运算结果也用补码表示。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机二进制编码</title>
      <link href="/2020/06/25/2020-06-25-Underlying-coding/"/>
      <url>/2020/06/25/2020-06-25-Underlying-coding/</url>
      
        <content type="html"><![CDATA[<h1 id="原码，反码，补码——，移码"><a href="#原码，反码，补码——，移码" class="headerlink" title="原码，反码，补码——，移码"></a>原码，反码，补码——，移码</h1><h2 id="一、实际背景"><a href="#一、实际背景" class="headerlink" title="一、实际背景"></a>一、实际背景</h2><p><strong>现实生活</strong>中：在计算机中所有的数据运算都是采用<strong>补码</strong>进行的（比如Windows中）<br>注意：负数用补码表示，如果相加的和为负，也采用补码表示。</p><h2 id="二、有符号数的原码，反码，补码"><a href="#二、有符号数的原码，反码，补码" class="headerlink" title="二、有符号数的原码，反码，补码"></a>二、有符号数的原码，反码，补码</h2><p>计算机中，<font color="red" size="5">有符号数</font>有3种表示法：原码–&gt;反码–&gt;补码（发展历程，记得“<strong>简书</strong>”上有篇文章讲解了这个发展的历程，告诉了为什么一步步，最后用的补码）<br>但是现在目前的电脑其实都是补码表示了，当然，<strong>也有书上说</strong>：负数是补码表示，正数是原码/反码/补码表示，行吧，也算是对的。。谁让他们编码真的一样）<br>（当然，个人从底层硬件实现来考虑，我觉得说正数是原码表示，负数是补码表示蛮好的，因为这样，我可以想象的是正数和负数首先全部编码为原码，然后根据符号位来判断，我要不要调用求补码的线路，正数不用，负数显然要）<br><font style="background: yellow">记忆：符号位，0为正，1为负</font></p><p>原码，反码，补码的正数表达是一样的</p><h3 id="1）原码："><a href="#1）原码：" class="headerlink" title="1）原码："></a>1）原码：</h3><p>原码就是符号位加上真值的绝对值<br>既最高位为符号位，0为正，1为负，其余表示数值的大小<br>比如<br>正数+3=00000011<br>负数-3=10000011</p><h3 id="2）反码："><a href="#2）反码：" class="headerlink" title="2）反码："></a>2）反码：</h3><p>原码，反码，补码的正数表达是一样的<br>正数+3=00000011</p><p><strong>负数</strong>的反码是在原码的基础上（<strong>符号位不变</strong>，其他位均取反）<br>负数-3=11111100</p><h3 id="3）补码"><a href="#3）补码" class="headerlink" title="3）补码"></a>3）补码</h3><p>原码，反码，补码的正数表达是一样的<br>正数+3=00000011</p><p>负数的补码是在<strong>反码</strong>的基础上（<strong>符号位不变</strong>，在末位加1）<br>负数-3=11111101</p><p><font style="background: yellow">至此，我们可以总结出一种<strong>求一个负数的补码</strong>的规则：</font><br>写出<strong>负数</strong>的原码-》符号位不变，其他位取反（求反码）-》符号位不变，末位+1（求补码）<br><strong>即：负数原码基础上，符号位不变，其他位取反，末位+1</strong><br>上面，也是国内主流的教材上的方法（比如清华的那本计算机组成的教材）</p><p>但是，我在<font style="background: yellow"><strong>另一些书</strong>上看到了下面两种求一个负数的补码方法：</font></p><blockquote><ul><li>1）（唯一的,也是独特的）<strong>负数的原码</strong>基础上，直接变补码规则如下：符号位不变，从数的右边往左开始数,遇到“0”不理它,<strong>直到遇到第一个“1”为止</strong>，这个<strong>第一次遇到的1它本身不变</strong>,但事继续向左（直到符号位右边一个）的每一位取反<br>比如：<br>原码1001 0010<br>补码1110 1110</li><li>2）先<strong>找到这个负数的正数编码</strong>，然后在这个基础上，所有位全取反，末位+1<br>比如：-1（我用8个比特说明）</li></ul><p>+1原码是0000 0001<br>全取反是1111 1110<br>末位加一是1111 1111<br>继续将，主流的方法补充到这，成为第3条</p><ul><li>3）负数原码基础上，符号位不变，其他位取反，末位+1<br>总结这三种方法：其实，本质都是等效的。。。我也不知道为什么，以前在自学的时候竟然看到了三种方法。</li></ul></blockquote><p>Tips:<strong>对于负整数</strong>，补码的补码是原码（强调是负整数，有的书没有强调是负整数）<br>比如：<br>原码1001<br>补码（我用方法3））<code>1001-&gt;1110-&gt;1111</code><br>原码（补码的补码，继续方法3）<code>1111-&gt;1000-&gt;1001</code></p><h2 id="三、有符号数到无符号数的过渡标题"><a href="#三、有符号数到无符号数的过渡标题" class="headerlink" title="三、有符号数到无符号数的过渡标题"></a>三、有符号数到无符号数的过渡标题</h2><p>重点：<br><strong>计算机不区分有符号数和无符号数</strong><br><strong>只有</strong><font color="red" size="5">有符号数</font>有原码，反码，补码<br>计算机中存储数据<br>a.无符号数——直接以对应的二进制表示<br>b.有符号数——补码形式表示，无论是计算还是存储</p><p>其实可以说无符号数没有原码，反码，补码一说，毕竟又不用分符号。</p><p>《C陷阱与缺陷》一书在“整数溢出”一节中指出：<br>如果算术运算符的一个操作数是有符号数，另一个是无符号数，那么有符号数会被转换为无符号数。</p><h2 id="四、关于无符号数和有符号一个注意的地方"><a href="#四、关于无符号数和有符号一个注意的地方" class="headerlink" title="四、关于无符号数和有符号一个注意的地方"></a>四、关于无符号数和有符号一个注意的地方</h2><h3 id="无符号数，竟然没有溢出一说"><a href="#无符号数，竟然没有溢出一说" class="headerlink" title="无符号数，竟然没有溢出一说?"></a>无符号数，竟然没有溢出一说?</h3><p>样例：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//4294967295对应二进制 11111111 11111111 11111111 1111111</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">4294967295</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"无符号输出:%u\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"有符号输出:%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u"</span><span class="token punctuation">,</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//输出结果如下： </span><span class="token comment" spellcheck="true">//无符号输出:4294967295</span><span class="token comment" spellcheck="true">//有符号输出:-1</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//此外编译器警告（unsigned int a=4294967295;）：</span><span class="token comment" spellcheck="true">//[Warning] this decimal constant is unsigned only in ISO C90</span></code></pre><p>无符号的加法</p><blockquote><p>A11111111 11111111 11111111 11111111（表示32位的无符号最大值4294967295）<br>A00000000 00000000 00000000 00000001（表示1）<br>1<strong>00000000 00000000 00000000 00000000<br>**丢弃最高位，所以等于0</strong>（硬件自动实现）<br>其实这种情况下个人认为是”溢出”了，但是可以通过下面的做法进行解释<br>//上面编译的，没有显示溢出的异常<br><font style="background: yellow">解释：这样溢出后就相当于对（2<sup>32</sup>-1）+1=2<sup>32</sup> ，再对和2<sup>32</sup> 取模2<sup>32</sup>得到为0</font></p></blockquote><p><strong>但是，有本书上的说法，让我对“溢出”这个概念有些混乱</strong><br>《C陷阱与缺陷》在“整数溢出”一节中指出，在<font color="red" size="5">无符号</font>算术运算中，没有所谓的“溢出”一说。<br>有个博客对它的解释是：<br>我想Koenig的思路可能是这样，钟表上，当下午1点的时候，没有任何人会说：“现在是12点溢出了。”<br>因为我们已经常识性地知道，我们的钟表上是没有13这个数字的。</p><blockquote><p>虽然，这么说，个人还是觉得这种在一个数据类型边界出现较反常的，我都应该关注一下、<br>到目前为止我看过的好几本书的说法，真的有点弄晕我的感觉。但是，至此，我个人倾向是忘记什么叫溢出。只关注底层的比特的变化会不会造成影响。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给数组赋相同值——fill</title>
      <link href="/2020/06/24/2020-06-24-fill/"/>
      <url>/2020/06/24/2020-06-24-fill/</url>
      
        <content type="html"><![CDATA[<h1 id="给数组赋相同值——fill"><a href="#给数组赋相同值——fill" class="headerlink" title="给数组赋相同值——fill"></a>给数组赋相同值——fill</h1><p>前提：<br>C++中头文件<code>#include&lt;algorithm&gt;</code></p><p>fill可以将<strong>数组</strong>（我记得我看过的有一本书，似乎上面说，数组其实在<code>C++</code>中也是一容器<font style="background: yellow" size="5">待补充是哪本书</font>）<br>或<strong>容器</strong>中的某一段区间赋为某个相同的值。</p><h2 id="一、fill的常用用法"><a href="#一、fill的常用用法" class="headerlink" title="一、fill的常用用法"></a>一、fill的常用用法</h2><p>和memset不同，这下你想给那个数组赋值是多少就可以<strong>任意</strong>选，你完全不用从bit的角度来思考很直观。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一维数组</span><span class="token function">fill</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">233</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>OJ中，做图论等一些题目，用<strong>邻接矩阵</strong>常用下面的方式</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> INF<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//二维数组</span><span class="token function">fill</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>MAXN<span class="token operator">*</span>MAXN<span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意这里a[0]</span></code></pre><p>十六进制0x3f3f3f3f<br>对应二进制<br>‭<code>0011 1111</code> <code>0011 1111</code> <code>0011 1111</code> <code>0011 1111‬</code></p><p>Tips:看二进制，个人还是习惯直接用Windows的calc</p><h2 id="二、对比memset和fill的语法，记忆"><a href="#二、对比memset和fill的语法，记忆" class="headerlink" title="二、对比memset和fill的语法，记忆"></a>二、对比memset和fill的语法，记忆</h2><h3 id="DevC-中memset声明"><a href="#DevC-中memset声明" class="headerlink" title="DevC++中memset声明"></a>DevC++中memset<strong>声明</strong></h3><p><code>void * __cdecl memset(void *_Dst,int _Val,size_t _Size);</code></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="DevC-中fill声明"><a href="#DevC-中fill声明" class="headerlink" title="DevC++中fill声明"></a>DevC++中fill<strong>声明</strong></h3><p><code>template&lt;typename _FIter, typename _Tp&gt;</code><br><code>void  fill(_FIter, _FIter, const _Tp&amp;);</code></p><p>所以</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一维数组</span><span class="token function">fill</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">233</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> INF<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//二维数组</span><span class="token function">fill</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>MAXN<span class="token operator">*</span>MAXN<span class="token punctuation">,</span>INF<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>//<font style="background: yellow" size="5">注意,fill中二维数组的这里</font><br><code>fill(a[0],a[0]+MAXN*MAXN,INF);</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给数组赋相同值——Memset</title>
      <link href="/2020/06/23/2020-06-23-Memset/"/>
      <url>/2020/06/23/2020-06-23-Memset/</url>
      
        <content type="html"><![CDATA[<h1 id="给数组赋相同值——Memset"><a href="#给数组赋相同值——Memset" class="headerlink" title="给数组赋相同值——Memset"></a>给数组赋相同值——Memset</h1><p>前提:<br>C语言:头文件<code>string.h</code><br>C++：头文件<code>cstring</code></p><h2 id="一、memset对数组中每个元素赋值"><a href="#一、memset对数组中每个元素赋值" class="headerlink" title="一、memset对数组中每个元素赋值"></a>一、memset对数组中每个元素赋值</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一维数组</span><span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//二维数组</span><span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一维字符数组。</span>    <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试结果是循环输出A 65</span></code></pre><p>//原因，65的二进制<code>0100</code> `0001‬，它的最后一个字节是也正好是这个<br>//然后，我要重复使用这个字节填入char，也正好一个字节，那就正好是它了</p><h2 id="二、底层原理"><a href="#二、底层原理" class="headerlink" title="二、底层原理"></a>二、底层原理</h2><p>原理：<font size="3">取二进制位的<strong>最后一个字节</strong></font>，<font style="background:yellow" size="5"><strong>重复使用</strong></font>它给目标赋值。</p><p>验证上述的例子：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1023</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">////测试结果是循环输出16843009</span></code></pre><p>解释，首先我们看一下<strong>-1023</strong>用int类型表示的补码是<br>‭<code>1111 1111</code> <code>1111 1111</code> <code>1111 1100</code> <code>0000 0001</code>‬<br>发现，<strong>最后一个字节</strong>的bits是<code>0000 0001</code>‬<br>我们将这个字节<strong>重复使用</strong>，放到一个<strong>int类型</strong>中去，也就组成了<br><code>0000 0001</code>‬ <code>0000 0001</code>‬ <code>0000 0001</code>‬ <code>0000 0001</code>‬<br>然后，我们将这个二进制化为十进制发现，是这样的，正好等于<strong>16843009</strong></p><h2 id="三、解释一些说法"><a href="#三、解释一些说法" class="headerlink" title="三、解释一些说法"></a>三、解释一些说法</h2><p>正是由于，只看那个最后一个字节。<br>所以，我们在编码的时候，常用用这个初始化全0，或者全-1<br>因为，他们的补码最后一个字节分别是<code>0000 0000</code> 和 <code>1111 1111</code><br>而其他的的最后一个字节的重复使用，对于赋值给不同类型的数据，效果不同，也就比较少用了。</p><p>PS:个人习惯的话，看自己喜欢吧，以前写俄罗斯方块，最初用的数组，后面学了位运算，发现还能这样精确的控制bit，我还优化了一次。（虽说，那样的思维强度比直观的用数组高一点）<br>当然，要是从<strong>可读性</strong>方面来看，还是数组的好一点，位运算的，可能对看自己代码的不友好。</p><p>此外，memset比<code>C++中fill</code>的速度快，所以，做OJ的一些题目，能用这种提速就尽量用这种。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim命令强化</title>
      <link href="/2020/06/22/2020-06-22-Vim/"/>
      <url>/2020/06/22/2020-06-22-Vim/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim命令强化"><a href="#Vim命令强化" class="headerlink" title="Vim命令强化"></a>Vim命令强化</h1><p>PS：所有测试在Redhat RHEL7（<strong>R</strong>ed<strong>H</strong>at <strong>E</strong>nterprise <strong>L</strong>inux <strong>7</strong>）通过</p><h2 id="一、Vim三种模式"><a href="#一、Vim三种模式" class="headerlink" title="一、Vim三种模式"></a>一、Vim三种模式</h2><p>Vim编辑器中设置了三种模式一命令模式、末行模式和编辑模式<br><strong>每种模式分别又支持多种不同的命令快捷键</strong></p><p>我们先弄清这三种模式的操作区别以及模式之间的切换方法</p><blockquote><ul><li>命令模式:控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</li><li>输人模式:正常的文本录入。</li><li>末行模式:保存或退出文档，以及设置编辑环境。</li></ul></blockquote><img src="https://github.com/HACV/Blog_Gallery/blob/master/2020/2020_6/2020_06_22_Vim_01.png?raw=true" width="80%"><p>说明：<br><code>vim 文件名</code> 则进入了vim的命令模式<br>1）在每次运行Vim编辑器时，<strong>默认进入</strong>命令模式，<br>2）此外，每次在编写完文档后需要先返回命令模式，然后再进人末行模式，执行文档.的保存或退出操作。<br><strong>在Vim中，无法直接从输人模式切换到末行模式。</strong></p><p>命令模式进入输入模式：</p><blockquote><ul><li>i取自insert插入，<blockquote><ul><li><code>i</code> 光标处<strong>前一个字符</strong>编辑</li><li><code>I</code> 大写的 i，光标所处<strong>行首</strong>编辑</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li><strong>a取append</strong>追加，（我记得在Python中有用过这个函数，然后似乎C++11中也有？）<blockquote><ul><li><code>a</code> 光标处<strong>后一个字符</strong>编辑</li><li><code>A</code> 光标所处<strong>行尾</strong>编辑</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>暂时没想到<br><code>o</code> 光标处<strong>向下</strong>新建一行编辑<br><code>O</code> 大写的 o，光标处<strong>向上</strong>新建一行编辑</li></ul></blockquote><h2 id="二、命令模式"><a href="#二、命令模式" class="headerlink" title="二、命令模式"></a>二、命令模式</h2><p>命令模式:控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p><blockquote><ul><li>剪切类（可以用作删除）（但是<strong>d却是delete删除，首字母</strong>）<blockquote><ul><li><code>dd</code>剪切(删除)<strong>光标所在整行</strong></li><li><code>5dd</code>删除(剪切)从光标处开始的5行</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>复制类（暂时用<strong>copy的末尾y记忆</strong>）<blockquote><ul><li><code>yy</code>复制<strong>光标所在整行</strong></li><li><code>5yy</code>复制从光标处开始的5行</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>粘贴（<strong>p是paste</strong>粘贴，首字符）<blockquote><ul><li><code>p</code>将之前剪切(dd)或复制(yy)过的数据粘贴到光标后面</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>撤销（<strong>u是unsay</strong>收回，撤回，首字母）<blockquote><ul><li><code>u</code>撤销上一步的操作</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>单个字符修改<blockquote><ul><li><code>X</code>删除光标所处的字符：X（和Windows下Ctrl+X有点类似了，但是只是删除）</li><li>按<code>R</code>后输入新的字符替换光标所处的字符</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>字符串匹配后续<blockquote><ul><li><code>n</code>显示搜索命令定位到的下一个字符串</li><li><code>N</code>显示搜索命令定位到的上一个字符串</li></ul></blockquote></li></ul></blockquote><h2 id="三、输入模式"><a href="#三、输入模式" class="headerlink" title="三、输入模式"></a>三、输入模式</h2><p>输人模式:正常的文本录入。</p><h2 id="四、末行模式"><a href="#四、末行模式" class="headerlink" title="四、末行模式"></a>四、末行模式</h2><p>末行模式:保存或退出文档，以及设置编辑环境。</p><p>末行模式的命令都写在你用<code>:</code>进去末行模式后面</p><blockquote><p>总的来说格式：<br><code>:命令</code>执行该命令</p></blockquote><p><strong>下面的都省略了<code>:</code></strong><br><code>整数</code>跳转到这个整数的那一行<br><code>w</code> 保存<br><code>q</code> 退出（quit）<br><code>q!</code>强制退出（放弃对文档的修改内容）</p><p><code>wq!</code>强制保存退出</p><blockquote><ul><li>看代码常用<blockquote><ul><li><code>set nu</code>显示行号，nu——num</li><li><code>set nonu</code>显示行号，</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>查找和替换<blockquote><ul><li>查找<blockquote><ul><li><code>/字符串</code> 在文本中<strong>从上至下</strong>搜索该字符串</li><li><code>?字符串</code> 在文本中<strong>从下至上</strong>搜索该字符串</li></ul></blockquote></li><li>替换<blockquote><ul><li><code>:s/one/two</code>将<strong>当前光标所在行</strong>的第一个 one替换成two</li><li><code>:s/one/two/g</code>将当<strong>前光标所在行</strong>的<strong>所有</strong>one替换成two</li><li><code>:%s/one/two/g 8s/one/two/g</code>将<strong>全文</strong>中的<strong>所有</strong>one替换成two</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux效率 </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他快捷键</title>
      <link href="/2020/06/21/2020-06-21-Other-shortcut/"/>
      <url>/2020/06/21/2020-06-21-Other-shortcut/</url>
      
        <content type="html"><![CDATA[<h1 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h1><h2 id="0、个人常用"><a href="#0、个人常用" class="headerlink" title="0、个人常用"></a>0、个人常用</h2><p>01.shift+F10  计算机右击的快捷键<br>02.Alt+回车     查看文件属性<br>19.Alt+双击文件 查看文件属性<br>03.Alt +F4关闭<br>04.CTRL+F4关闭（关闭当前页面，比如两个网页，那就关闭当前这一个网页，留另一个）<br>05.Ctrl+W：关闭当前页面（好像功能和04一样）</p><p>PRINT SCREEN<br>（键盘上常常简写为：prt scr）：将当前屏幕以图象方式拷贝到剪贴板（平常无意间的截图，就是这个引起的吗？？恩，是的）<br>ALT+PRINT SCREEN:将当前活动程序窗口以图象方式拷贝到剪贴板</p><p>以下用来代替鼠标：<br>Tab键按下去会移动 选中；<br>方向键按下去，本来桌面上没有任何被选中的，现在就有了选中出现；</p><p>Ctrl+Shift+N新建文件夹，并且放在那儿等着命名了<br>CTRL+ALT+DELETE 可以给一个打开“任务管理器”的链接</p><h2 id="一、Ctrl快捷键"><a href="#一、Ctrl快捷键" class="headerlink" title="一、Ctrl快捷键"></a>一、Ctrl快捷键</h2><p>Ctrl+空格 中英文切换<br>Ctrl+回车 QQ号中发送信息<br>Ctrl+Home 光标快速移到文件头<br>Ctrl+End 光标快速移到文件尾<br>Ctrl+Esc 显示开始菜单<br>Ctrl+Shift+&lt; 快速缩小文字<br>Ctrl+Shift+&gt; 快速放大文字<br>Ctrl+拖动文件 复制文件<br>Ctrl+Backspace 启动\关闭输入法<br>拖动文件时按住Ctrl+Shift 创建快捷方式</p><p>（Ctrl+F数字的快捷键）<br>CTRL+F4:关闭当前应用程序中的当前文本（如word中）关闭当前标签(窗口)<br>Ctrl+F5 在IE中强行刷新<br>CTRL+F6：切换到当前应用程序中的下一个文本（加shift 可以跳到前一个窗口）<br>按页面打开的先后时间顺序向前切换标签(窗口)<br>Ctrl+F11　隐藏或显示菜单栏</p><p>Ctrl+Tab　以小菜单方式向下切换标签(窗口)<br>Ctrl+Enter　域名自动完成<code>[url=]http://www.**.com[/url](内容可更改,Maxthon选项→地址栏→常规)</code>/另:当输入焦点在搜索栏中时,为高亮关键字<br>Ctrl+拖曳　保存该链接的地址或已选中的文本或指定的图片到一个文件夹中(保存目录可更改,Maxthon选项→保存)<br>Ctrl+小键盘’+’　当前页面放大20%<br>Ctrl+小键盘¬¬¬’-‘　当前页面缩小20%<br>Ctrl+小键盘’*’　恢复当前页面的缩放为原始大小<br>Ctrl+Alt+S　自动保存当前页面所有内容到指定文件夹(保存路径可更改,Maxthon选项→保存)<br>Ctrl+Shift+小键盘’+’　所有页面放大20%<br>Ctrl+Shift+小键盘’-‘　所有页面缩小20%<br>Ctrl+Shift+F　输入焦点移到搜索栏<br>Ctrl+Shift+G　关闭“简易收集”面板<br>Ctrl+Shift+H　打开并激活到你设置的主页<br>Ctrl+Shift+N　在新窗口中打开剪贴板中的地址,如果剪贴板中为文字,则调用搜索引擎搜索该文字(搜索引擎可选择,Maxthon选项→搜索)<br>Ctrl+Shift+S　打开“保存网页”面板(可以将当前页面所有内容保存下来,等同于Ctrl+S)　<br>Ctrl+Shift+W　关闭除锁定标签外的全部标签(窗口)<br>Ctrl+Shift+F6　按页面打开的先后时间顺序向后切换标签(窗口)<br>Ctrl+Shift+Tab　以小菜单方式向上切换标签(窗口)<br>Ctrl+Shift+Enter　域名自动完成<br>Alt+1　保存当前表单<br>Alt+2　保存为通用表单<br>Alt+A　展开收藏夹列表 </p><h2 id="二、Alt快捷键"><a href="#二、Alt快捷键" class="headerlink" title="二、Alt快捷键"></a>二、Alt快捷键</h2><p>01.Alt+空格+C 关闭窗口 111<br>02.Alt+空格+N 最小化当前窗口 111<br>03.Alt+空格+R 恢复最小化窗口 111<br>04.Alt+空格+X 最大化当前窗口 111<br>05.Alt+空格+M 移动窗口<br>06.Alt+空格+S 改变窗口大小<br>07.Alt+Tab 两个程序交换 而alt+tab+shift键则可以反向显示当前打开的窗口。111<br>08.ALT+ESC: 切换当前程序 （注意与上面的区别）111<br>09.Alt+255 QQ号中输入无名人<br>10.Alt+F 打开文件菜单 111<br>11.Alt+V 打开视图菜单<br>12.Alt+E 打开编辑菜单<br>13.Alt+I 打开插入菜单<br>14.Alt+O 打开格式菜单<br>15.Alt+T 打开工具菜单<br>16.Alt+A 打开表格菜单<br>17.Alt+W 打开窗口菜单<br>18.Alt+H 打开帮助菜单<br>20.Alt+X 关闭C语言<br>21.ALT+BACKSPACE 或 CTRL+Z 撤销上一步的操作<br>22.ALT+SHIFT+BACKSPACE重做上一步被撤销的操作<br>23.ALT+SPACEBAR:打开程序最左上角的菜单<br>24.ALT+ENTER:将windows下运行的MSDOS窗口在窗口和全屏幕状态间切换</p><h2 id="三、Shift快捷键"><a href="#三、Shift快捷键" class="headerlink" title="三、Shift快捷键"></a>三、Shift快捷键</h2><p>01.Shift+空格 半\全角切换<br>02.Shift + Delete 永久删除所选项，而不将它放到“回收站”中。<br>03.拖动某一项时按 CTRL 复制所选项。<br>04.拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。<br>05.SHIFT+F10或鼠标右击：打开当前活动项目的快捷菜单<br>06.SHIFT：在放入CD的时候按下不放，可以跳过自动播放CD。在打开word的时候按下不放，可以跳过自启动的宏<br>将光盘插入到CD-ROM驱动器时按SHIFT键阻止光盘自动播放 </p><h2 id="四、资源管理器"><a href="#四、资源管理器" class="headerlink" title="四、资源管理器"></a>四、资源管理器</h2><p>NUMLOCK+数字键盘的减号(-)折叠所选的文件夹<br>NUMLOCK+数字键盘的加号(+)显示所选文件夹的内容<br>NUMLOCK+数字键盘的星号(*)显示所选文件夹的所有子文件夹<br>向左键 当前所选项处于“展开”状态时折叠该项，或“选定”其（父文件夹）<br>向右键  当前所选项处于“折叠”状态时展开该项，或“选定”（第一个子文件夹） </p><h2 id="五、辅助功能"><a href="#五、辅助功能" class="headerlink" title="五、辅助功能"></a>五、辅助功能</h2><p>按右边的SHIFT键八秒钟切换筛选键的开和关<br>按SHIFT五次切换粘滞键的开和关<br>按NUMLOCK五秒钟切换切换键的开和关<br>左边的ALT+左边的SHIFT+NUMLOCK切换鼠标键的开和关<br>左边的ALT+左边的SHIFT+PRINTSCREEN切换高对比度的开和关 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ctrl快捷键</title>
      <link href="/2020/06/20/2020-06-20-Ctrl-shortcut/"/>
      <url>/2020/06/20/2020-06-20-Ctrl-shortcut/</url>
      
        <content type="html"><![CDATA[<h1 id="Ctrl快捷键"><a href="#Ctrl快捷键" class="headerlink" title="Ctrl快捷键"></a>Ctrl快捷键</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Ctrl+26个字母的快捷键</p><blockquote><ul><li>//有点记忆英语词汇的既视感，乱序版和顺序版。。。好在这次没有abandon了</li></ul></blockquote><p><code>Ctrl+A</code> 全部选中当前页面内容<br><code>Ctrl+B</code> word和一些文本操作软件中——粗体<br><code>Ctrl+C</code> 复制当前选中内容<br><code>Ctrl+D</code> 浏览器——收藏（把当前页面添加到收藏夹中）<br><code>Ctrl+E</code> <strong>（这个测试很怪异）</strong>打开或关闭“搜索”侧边栏（各种搜索引擎可选）</p><p><code>Ctrl+F</code> 查找<br><code>Ctrl+G</code> <strong>（未测试完全）</strong>打开或关闭“简易收集”面板（但是，<strong>似乎我更加常用来实现和F类似的功能）</strong><br><code>Ctrl+H</code> 浏览器——打开“历史”侧边栏<br><code>Ctrl+I</code> word中为斜体，打开“收藏夹”侧边栏/另:将所有垂直平铺或水平平铺或层叠的窗口恢复 ？（<strong>应用场景复杂</strong>）<br><code>Ctrl+J</code> word中两端对齐，谷歌浏览器中打开“下载”页</p><p><code>Ctrl+K</code>　<strong>（未测试完全）</strong>关闭除当前和锁定标签外的所有标签<br><code>Ctrl+L</code>　<strong>（未测试完全）</strong>打开“打开”面版（可以在当前页面打开Iternet地址或其他文件…）<br><code>Ctrl+M</code>  <strong>（未测试完全）</strong> word——左缩进<br><code>Ctrl+N</code>　word,matlab,python,C各种编辑器——新建一个空白窗口<br><code>Ctrl+O</code>　打开“打开”面版（可以在当前页面打开Iternet地址或其他文件…）</p><p><code>Ctrl+P</code>　打开“打印”面板（可以打印网页,图片什么的…）<br><code>Ctrl+Q</code>　<strong>（未测试完全）</strong>打开“添加到过滤列表”面板（将当前页面地址发送到过滤列表）<br><code>Ctrl+R</code>　刷新当前页面（在前端调试的时候，我用过）<br><code>Ctrl+S</code>　打开“保存网页”面板（可以将当前页面所有内容保存下来）<br><code>Ctrl+T</code>　<strong>（未测试完全）</strong>垂直平铺所有窗口 </p><p><code>Ctrl+U</code>  word——下划线<br><code>Ctrl+V</code>　粘贴当前剪贴板内的内容<br><code>Ctrl+W</code>　关闭当前标签（窗口）<br><code>Ctrl+X</code>　剪切当前选中内容（一般只用于文本操作）<br><code>Ctrl+Y</code>　<strong>重做</strong>刚才动作（一般只用于文本操作）</p><p><code>Ctrl+Z</code>　撤消刚才动作（一般只用于文本操作）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word快捷键</title>
      <link href="/2020/06/19/2020-06-19-Word-shortcut/"/>
      <url>/2020/06/19/2020-06-19-Word-shortcut/</url>
      
        <content type="html"><![CDATA[<h1 id="Word快捷键"><a href="#Word快捷键" class="headerlink" title="Word快捷键"></a>Word快捷键</h1><p>记住常用的就好了</p><h2 id="一、常用的"><a href="#一、常用的" class="headerlink" title="一、常用的"></a>一、常用的</h2><p>Ctrl+Y：重复上一操作部分操作不适用，也是是<strong>反向撤销</strong><br>CTRL+E 居中（在选中目标情况下）<br><code>Ctrl+[</code>     缩小选中的文字或者先缩小文字号，然后我们再打字就变小了<br><code>Ctrl+]</code>     放大选中的文字<br><code>Ctrl+shift+ +</code> 上标<br><code>Ctrl+ +</code> 下标</p><p>Ctrl+F：打开“查找与替换”对话框，并定位在“查找”标签上。<br>Ctrl+G：打开“查找与替换”对话框，并定位在“定位”标签上。 </p><p>Ctrl+H：打开“查找与替换”对话框，并定位在“替换”标签上。 </p><p>CTRL+L 左对齐（在选中目标情况下）<br>CTRL+R 右对齐（在选中目标情况下）<br>CTRL+J 两端对齐（在选中目标情况下）</p><p>CTRL+D     字体设置（在选中目标情况下）打开“字体”对话框，快速完成字体的各种设置。 </p><p>CTRL+P 打印<br>CTRL+A 全选<br>CTRL+O     打开    然后就可以用四个方向键控制一点其他的</p><p>CTRL+N 新建文档窗口 </p><p>Ctrl+F4或者Ctrl+W 关闭当前文档。</p><p>CTRL+U 绘制下划线（在选中目标情况下）;<br>CTRL+B 加粗文字（在选中目标情况下）;<br>CTRL+I 倾斜文字（在选中目标情况下）; </p><p>CTRL+K 插入超链接 </p><p>Ctrl+A（或Ctrl+小键盘上数字5）：选中全文。<br>Ctrl+X：将选中的文字剪切到剪贴板中。<br>Ctrl+Z：撤销刚才进行的操作（可以多次使用）。<br>Ctrl+W：关闭当前文档 </p><p>Ctrl+V：将剪贴板中的文本或图片粘贴到光标处。若剪贴板中有多个内容，则将最后一条内容粘贴到光标处。  </p><h2 id="二、其他"><a href="#二、其他" class="headerlink" title="二、其他"></a>二、其他</h2><p>CTRL+M 左边距（在选中目标情况下）;<br>CTRL+Q 两边对齐（无首行缩进），（在选中目标情况下）或将光标放置目标文字的段尾，亦可操作<br>CTRL+T/Y 可进行首行缩进（将光标移到需做此操作的段尾，或将此段选中进行操作 </p><p>Ctrl+Shift+L：给光标所在行的文本加上“项目符号”<br>Ctrl+M：同时增加首行和悬挂缩进<br>Ctrl+Shift+M：同时减少首行和悬挂缩进<br>Ctrl+O（或Ctrl+F12）：打开“打开”对话框<br>Ctrl+P（或Ctrl+Shift+F12）：打开“打印”对话框<br>Ctrl+R：使光标所在行的文本右对齐<br>Ctrl+S：为新文档打开“另保存为”对话框，或对当前文档进行保存<br>Ctrl+T：增加首行缩进<br>Ctrl+Shift+T：减少首行缩进 </p><p>Ctrl+0：将选中的文本每段前增加12磅的间距。<br>Ctrl+1：若选中的文本行距不是“单倍行距”，则将其快速设置为“单倍行距”。<br>Ctrl+2：将选中的文本行距设置为“两倍行距”。<br>Ctrl+5：将选中的文本行距设置为“1.5倍行距”。<br>Ctrl+F2：快速执行“打印预览”功能。<br>Ctrl+F5：使窗口还原到最大化之前的状态。<br>Ctrl+Shift+F5：打开“书签”对话框。<br>Ctrl+Shift+F8：激活列选择功能，即通常所说的选择竖块文本（再按一次或按ESC键，取消该功能）。<br>Ctrl+F9：在光标处插入一域记号“{}”（注意：直接输入的一对大括号不能作为域记号）。<br>Ctrl+F5：使窗口还原到最大化之前的状态（再按一次，就会使窗口再次最大化）。<br>Ctrl+Deltet：删除光标后面的一个英文单词或一个中文词语（可反复使用）。<br>Ctrl+退格键：删除光标前面的一个英文单词或一个中文词语（可反复使用）。<br>Ctrl+Enter：将光标后面的内容快速移到下一页。<br>Ctrl+End：快速将光标移到文末。<br>Ctrl+Home（或Ctrl+Page Up）：快速将光标移到文首。<br>Ctrl+Insert+Insert(即按两下Insert键)：快速打开或更改“任务窗格”到“剪贴板”状态。<br>Ctrl+~：打开中文输入法的“在线造词”功能<br><code>Ctrl++</code>：快速切换到下标输入状态（再按一次恢复到正常状态）<br><code>Ctrl+Shift++</code>：快速切换到上标输入状态（再按一次恢复到正常状态）<br><code>Ctrl+→</code>：按英文单词或中文词语的间隔向后移动光标。<br><code>Ctrl+←</code>：按英文单词或中文词语的间隔向前移动光标。<br><code>Ctrl+Q</code>：段落重置 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win快捷键</title>
      <link href="/2020/06/18/2020-06-18-Win-shortcut/"/>
      <url>/2020/06/18/2020-06-18-Win-shortcut/</url>
      
        <content type="html"><![CDATA[<h1 id="Win快捷键"><a href="#Win快捷键" class="headerlink" title="Win快捷键"></a>Win快捷键</h1><h2 id="第1部分"><a href="#第1部分" class="headerlink" title="第1部分"></a>第1部分</h2><p>在屏幕是桌面的时候的快捷键的意思</p><p>WIN+Q   打开了搜索    似乎Q是question  ？<br>WIN+W   打开了便笺和草图   我的win10上是的<br>WIN+E    打开资源管理器<br>WIN+R    打开“运行”对话框<br>WIN+T  后面</p><p>WIN+Y  无<br>WIN+U 讲述人的设置  打开“辅助工具管理器”（我的Windows10电脑是打开了“设置”）<br>WIN+I  打开设置<br>WIN+O  无<br>WIN+P  投影</p><hr><p>WIN+A   打开新通知，或者能够更快的去编辑右下角的网络啥的<br>WIN+S   似乎和WIN+Q一样，，search<br>WIN+D    显示桌面<br>WIN+F反馈中心<br>打开“查找：所有文件”对话框（我的Windows10电脑是打开了“反馈中心”）搜索文件或文件夹<br>WIN+G</p><p>WIN+H    无<br>WIN+J    无<br>WIN+K   连接  比如什么无线显示器和音频设备（应该有用）<br>WIN+L   锁屏<br>win+L 快速锁屏lock</p><p>win+E 资源管理器</p><hr><p>WIN+Z    无<br>WIN+X<br>WIN+C    无<br>WIN+V    无<br>WIN+B   后面</p><p>WIN+N    无<br>WIN+M    无</p><hr><p>————————————这两个用于强化win+X<br>WIN+T    到达那个左下角应用第一个位置<br>WIN+B  到达那个右下角第一个位置   再结合左右《—和—》就可以控制网络开关了</p><h2 id="第2部分"><a href="#第2部分" class="headerlink" title="第2部分"></a>第2部分</h2><p>1.WIN+X<br>然后再按一个键盘就可以去往<br>    I PS<br>    A 管理员下的PS<br>    F 应用和功能——-似乎在这个先卸载软件更加清晰</p><h2 id="第3部分"><a href="#第3部分" class="headerlink" title="第3部分"></a>第3部分</h2><p>win+1-9啥的就可以直接打开你的Windows系统的下面的任务栏中对应的一些程序！！</p><p>而且还有一个用途，要是下面的程序不是固定的，那么其实也是可以调用的</p><p>————————用win+B和win+T可以改善下面的<br>TAB 1次 到 左下角第一个win的图标<br>TAB 2次 到 左下角第2个图标  我的是搜索<br>TAB 3次 到 左下角第3个图标 我的是任意，我放的第一个固定的应用<br>此时就可以接着用《—和—》 左右选中去 下面的固定的应用</p><p>TAB 4次 到 右下角第一个图标<br>此时就可以接着用《—和—》 左右选中去 右边的固定的地方了，<br>比如这样就可以去往控制我的网络开关等</p><p>Win快捷键<br>01.Windows键+BREAK： 打开“系统属性”对话框（可以看是64位还是32位等信息）</p><p>05.windows键或CTRL+ESC打开开始菜单<br>06.Windows键+CTRL+M:重新将恢复上一项操作前窗口的大小和位置<br>07.Windows键+CTRL+F打开“查找：计算机”对话框（这个OK）　　 </p><p>Windows键+F1帮助<br>Windows键+TAB在打开的项目之间切换</p><h2 id="快捷键熟练使用我的电脑（不一定用这个）"><a href="#快捷键熟练使用我的电脑（不一定用这个）" class="headerlink" title="快捷键熟练使用我的电脑（不一定用这个）"></a>快捷键熟练使用我的电脑（不一定用这个）</h2><p>我的Windows10事件的</p><p>win+E进入之后</p><p>Alt能够显示上面几个数字的用途<br>其中：</p><p>1）  F——进入文件  （其实也可以一次性之间按Alt和F进入文件） 进入文件后就可以直接输入以下<br><code>N  R  O H  C  1   2   3   4  5  6  7 等等它们所对应的文件夹或者powershell</code></p><p><code>1</code>——看当前选中的东西的属性（其实也可以一次性之间按Alt和1卡属性）</p><p><code>2</code>——在当前下面新建文件夹并且能够自动让你重命名（其实也可以一次性之间按Alt和2新建文件夹）</p><p>在我的电脑中，按那个F4就能到达那个类似于浏览器的浏览框中。<br>用D:\啥的，回车后就能去往D盘</p><p>似乎在我的电脑中F10和Alt是一样的功能。</p><p>此外F1到F12之间，F3的功能是多了一个搜索（感觉没啥用————还未领悟）</p><p>重点：Alt+F在谷歌浏览器中是 打开文件菜单</p><p>小键盘替代鼠标<br>打开方式：键盘左边的Alt+左边的shift+Numlock   后面会显示一个对话框，确定就OK<br>关闭的方式也是那3个键，只是最后按否。</p><p>进入这个模式之后，<br>移动鼠标图符。鼠标键盘共有八个方向键，键“8”、“2”、“4”、“6”、<br>“7”、“1”、“9”、“3”的功能分别为使鼠标图符向上、下、左、右、<br>左上、左下、右上、右下移动，键按下时鼠标图符的移动是由慢到快加速<br>进行的，当到达目标位置时松开即可。</p><p>进入这个模式之后，Numlock就是开关这个替换。。此外，开了这个的话，小键盘就不能用了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows效率 </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器快捷键</title>
      <link href="/2020/06/17/2020-06-17-Browser-shortcut/"/>
      <url>/2020/06/17/2020-06-17-Browser-shortcut/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器快捷键"><a href="#浏览器快捷键" class="headerlink" title="浏览器快捷键"></a>浏览器快捷键</h1><h2 id="一、个人常用（常用谷歌）"><a href="#一、个人常用（常用谷歌）" class="headerlink" title="一、个人常用（常用谷歌）"></a>一、个人常用（常用谷歌）</h2><p><strong>注意：分清，什么是窗口，什么是标签页</strong><br>——————————————————————————————————</p><p>浏览器中以下在（<strong>谷歌，QQ浏览器，Micosoft Edge</strong>）测试通过</p><blockquote><ul><li>1）<strong>按住Alt再点击链接    （下载链接）</strong></li><li>2）<code>Alt+D或者Ctrl+L</code>        选中网址区域中的内容（效果和F6差不多一样——注意，F6和TAB差不多会慢慢走动，所以准确来说Alt+D才是最准确的），还可以配合一个：接着键入网址，然后按 Alt+Enter 键在新标签页中打开网址</li><li>3）<code>Alt +RIGHT ARROW</code>（其实就是→）：显示前一页（前进键） </li><li>4）<code>Alt +LEFT ARROW</code>（其实就是←）：显示后一页（后退键） </li><li><code>Ctrl+shit+DEL</code>     调出界面—清楚浏览记录</li><li><code>Ctrl+shift+T</code>    重新打开上次关闭的标签页，特别值得一谈的是Google可以记住最近关闭的10个标签页</li><li><code>Ctrl+T</code>        新建标签页    </li><li><code>Ctrl+N</code>      新建窗口（和Ctrl+T有些不同）窗口似乎是一个新的进程，而标签页是一个进程中的其他的？</li><li><code>Ctrl+J</code>        查看“下载”页</li><li><code>Ctrl+H</code>        查看“历史记录”页</li><li><code>Ctrl+D</code>        将当前网页 加入书签？？？？那么如何取消收藏呢？？？</li><li><code>Alt+F4</code>        关闭当前窗口</li></ul></blockquote><ul><li>按住Ctrl点击链接    从后台在新标签页中打开链接，但你仍然停留在（当前）标签页中</li><li>按住Ctrl+shift点击链接    在新标签页中打开链接，同时切换到（新打开）的标签页</li></ul><p>1）Ctrl+1到8可以直接切换到指定位置编号的标签页，你按下的数字就代表那个相应的标签位置。</p><blockquote><ul><li>Ctrl+9切换到最后的标签页面</li><li>CTRL+TAB：在页面上的各框架中切换（加shift反向）</li></ul></blockquote><p>2）<font style="background: yellow" size="5">地址栏中，<strong>键入www.和.com之间的部分</strong>，然后按<strong>Ctrl+enter</strong>会自动，为你在地址栏中的内容添加www.和.com</font><br>3）地址栏中 键入网址，然后按Alt+enter<br>在（新标签页）中打开该网站</p><p>Ctrl+P    打印当前页<br>Ctrl+S    保存当前页<br>F5    重新加载当前页<br>ESC    取消加载当前页<br>Ctrl+F    在网页长查找</p><p><strong>Ctrl+U    查看网页源代码</strong>（前端代码用）<br>Ctrl+F5    重新加载当前页，但是忽略缓存内容<br>F3    查找与你“在网页上查找”输入框总匹配的下一项<br>shift+F3查找与你“在网页上查找”输入框总匹配的上一项</p><h3 id="二、（谷歌中的快捷键）QQ浏览器，Micosoft-Edge不通过"><a href="#二、（谷歌中的快捷键）QQ浏览器，Micosoft-Edge不通过" class="headerlink" title="二、（谷歌中的快捷键）QQ浏览器，Micosoft Edge不通过"></a>二、（谷歌中的快捷键）QQ浏览器，Micosoft Edge不通过</h3><p>Ctrl+Shift+N    新建是无痕浏览模式的窗口（可以用于减少电脑缓存）<br>Ctrl+O        是用该浏览器打开电脑上的东西</p><h3 id="三、（谷歌和QQ浏览器中的快捷键）Micosoft-Edge不通过"><a href="#三、（谷歌和QQ浏览器中的快捷键）Micosoft-Edge不通过" class="headerlink" title="三、（谷歌和QQ浏览器中的快捷键）Micosoft Edge不通过"></a>三、（谷歌和QQ浏览器中的快捷键）Micosoft Edge不通过</h3><p>Shift+ESC    查看浏览器的“任务管理器”——类似于电脑的“任务管理器”的东西</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10专用快捷键</title>
      <link href="/2020/06/16/2020-06-16-Special-shortcut-key/"/>
      <url>/2020/06/16/2020-06-16-Special-shortcut-key/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows10专用快捷键"><a href="#Windows10专用快捷键" class="headerlink" title="Windows10专用快捷键"></a>Windows10专用快捷键</h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p>记住常用的：</p><p><strong>WIN+X</strong>先一会，然后按F就可以了    Windows  快速打开要去卸载软件</p><p><strong>ctrl+win+D</strong>  新建另一个桌面，并且转到那里</p><p><strong>Ctrl+win+左或右</strong>，可以在；领近的几个桌面中切换</p><p>Ctrl+WIN+F4  关闭当前桌面</p><p>使用win+ctrl+f4快捷键可以关闭当前虚拟桌面，如果当前<br>的虚拟桌面有窗口，则窗口全部跑到前一个虚拟桌面上去</p><p>win+a快捷键：<br>使用win+a快捷键可以打开操作中心</p><p>Windows10  <strong>内置截图</strong>功能，快捷键是<strong>win+shift+S</strong><br>截图后，他就在剪切板中了。<br>直接粘贴到需要的地方就行了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows效率 </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows全局快捷键</title>
      <link href="/2020/06/16/2020-06-16-Global-shortcut/"/>
      <url>/2020/06/16/2020-06-16-Global-shortcut/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows全局快捷键"><a href="#Windows全局快捷键" class="headerlink" title="Windows全局快捷键"></a>Windows全局快捷键</h1><h2 id="一、常规"><a href="#一、常规" class="headerlink" title="一、常规"></a>一、常规</h2><h3 id="1）PrtSc键（Print-Screen）的使用："><a href="#1）PrtSc键（Print-Screen）的使用：" class="headerlink" title="1）PrtSc键（Print Screen）的使用："></a>1）<font style="background: yellow" size="5">PrtSc键（Print Screen）</font>的使用：</h3><blockquote><ul><li>1）<strong>PrtSc</strong>只要按下这个PrtSc键那么就可以在文本中粘贴<br>你按下此键 就会在win默认的剪贴板里暂存了刚才的屏幕截图.这时候你打开win自带的画图工具,然后按ctrl+v,就会把你刚才截到的图粘在画图里了.这个功能主要是为了方便那些没有办法截到的动态片刻例如电影的某个场景.（<strong>不能</strong>在“照片”中找到截下的图）</li><li>2）<strong>win+ PrtSc</strong>不仅可以上面那么做，而且<strong>能够</strong>在“照片”中找到截下的图</li></ul><p><strong>注意：以上是截全屏</strong></p><ul><li>3）<strong>Alt+ PrtSc</strong>则是对当前窗口进行截图。如你打开“我的电脑”后，用此法就截取“我的电脑”窗口的内容。（<strong>不能</strong>在“照片”中找到截下的图）</li></ul></blockquote><p>Print Screen /Sysrq  打印屏幕/系统请求</p><h3 id="2）Scroll-Lock（屏幕）滚动锁定"><a href="#2）Scroll-Lock（屏幕）滚动锁定" class="headerlink" title="2）Scroll Lock（屏幕）滚动锁定"></a>2）<font style="background: yellow" size="5">Scroll Lock（屏幕）滚动锁定</font></h3><p>scroll lock就是“滚动锁”的意思，此键在win系统中一般不用，但是部分软件偶尔会使用到，比方说EXCEL办公软件，如果Scroll Lock关闭的情况，使用翻页键Page Down与Page Up时，单元格选定区域会随之发生移动。如果大家按下了Scroll Lock键后，则不会移动选定的单元格。</p><p>在电脑初期DOS系统时代，我们经常需要使用Scroll Lock键，由于屏幕显示是字符方式，每屏可以显示25行，每行有80个字符，该键的作用是查阅比较长的文本时进行翻滚，所以在DOS系统下很是有用，随着win系统可视操作系统的出现，大家查阅网页、文本都不需要键盘上scroll lock键了。</p><h3 id="3）Pause-Break-暂停-中断"><a href="#3）Pause-Break-暂停-中断" class="headerlink" title="3）Pause /Break   暂停/中断"></a>3）<font style="background: yellow" size="5">Pause /Break   暂停/中断</font></h3><p><strong>System Request（系统请求）</strong></p><blockquote><ul><li>滚动锁定<strong>Scroll Lock</strong>：灯亮时，按移动键时屏幕滚动；灯灭时，光标滚动；</li><li>暂停中断<strong>Pause Break</strong>：在想中断一些操作时，比如中断打印，则按此键，打印暂停。</li></ul></blockquote><h3 id="4）三个能让指示灯亮的键：（都含有LOCK这个单词）"><a href="#4）三个能让指示灯亮的键：（都含有LOCK这个单词）" class="headerlink" title="4）三个能让指示灯亮的键：（都含有LOCK这个单词）"></a>4）<font style="background: yellow" size="5">三个能让指示灯亮的键：（都含有LOCK这个单词）</font></h3><p>Capitalization<br>Caps Lock（大写锁定）<br>Num Lock（数字锁定）<br>Scroll Lock（滚动锁定）</p><h2 id="二、F1到F12的用途"><a href="#二、F1到F12的用途" class="headerlink" title="二、F1到F12的用途"></a>二、F1到F12的用途</h2><p>F1帮助<br>F2改名<br>F3搜索<br>F4地址<br>F5刷新<br>F6切换<br>F10或ALT菜单 </p><h2 id="三、键盘上按钮的作用"><a href="#三、键盘上按钮的作用" class="headerlink" title="三、键盘上按钮的作用"></a>三、键盘上按钮的作用</h2><p>END显示当前窗口的底端<br>HOME显示当前窗口的顶端 </p><h2 id="四、个人常用全局快捷键"><a href="#四、个人常用全局快捷键" class="headerlink" title="四、个人常用全局快捷键"></a>四、个人常用全局快捷键</h2><p>shift+F10  鼠标右击的快捷键<br>ALT+TAB切换<br>ALT+ESC切换<br>ALT+空格键窗口菜单<br>CTRL+ESC开始菜单<br>拖动某一项时按CTRL复制所选项目<br>拖动某一项时按CTRL+SHIFT创建快捷方式 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows效率 </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows和Linux下盘符</title>
      <link href="/2020/06/15/2020-06-15-Directory/"/>
      <url>/2020/06/15/2020-06-15-Directory/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows和Linux切换路径的区别"><a href="#Windows和Linux切换路径的区别" class="headerlink" title="Windows和Linux切换路径的区别"></a>Windows和Linux切换路径的区别</h1><h2 id="一、Linux下"><a href="#一、Linux下" class="headerlink" title="一、Linux下"></a>一、Linux下</h2><p>桌面<code>/</code>学期资源<br>PS：45度，这大概是Linux唯一一个，正向的常人思维吧<br>Windows虽然用图形界面赢得了大多数人操作的便利，但是在这个斜杠上，就不如Linux的常规了。</p><h2 id="二、Windows下"><a href="#二、Windows下" class="headerlink" title="二、Windows下"></a>二、Windows下</h2><p>桌面<code>\</code>学期资源</p><h2 id="三、Windows下Cmd"><a href="#三、Windows下Cmd" class="headerlink" title="三、Windows下Cmd"></a>三、Windows下Cmd</h2><h3 id="《1》特点"><a href="#《1》特点" class="headerlink" title="《1》特点"></a>《1》特点</h3><blockquote><ul><li>1）cmd中命令，<strong>不区分大小写</strong></li><li>2）从<font style="background: yellow" size="5"><strong>一个磁盘到另一个磁盘目录</strong></font>，需要修改磁盘，<font style="background: yellow" size="5"><strong>不能直接cd一步到底</strong></font>，详情见下面。</li></ul></blockquote><h3 id="《2》CMD命令进入另一个磁盘的目录"><a href="#《2》CMD命令进入另一个磁盘的目录" class="headerlink" title="《2》CMD命令进入另一个磁盘的目录"></a>《2》CMD命令进入另一个磁盘的目录</h3><blockquote><ul><li>进入某个磁盘，直接盘符代号：如<code>D:</code>不能用cd命令切换</li><li>然后才能用那个文件在<strong>这个（注意）</strong>盘符的相对路径或者绝对路径。</li></ul></blockquote><p>场景样例</p><blockquote><p>//当前目录是C:\Users<br>//我要去D:____Software\00.Mygithub_web\blog\HACV<br>解决方案1）<strong>个人习惯用</strong></p></blockquote><pre class=" language-cmd"><code class="language-cmd">D:cd D:\____Software\00.Mygithub_web\blog\HACV</code></pre><p>解决方案2）</p><pre class=" language-cmd"><code class="language-cmd">cd D:\____Software\00.Mygithub_web\blog\HACVD:</code></pre><p>//注意，这种方式的，第1条语句执行后发现，什么也没变<br>//但是当第2条语句执行之后，就直接给你进入了<code>D:\____Software\00.Mygithub_web\blog\HACV</code><br>若一打开CMD的时候运行<code>CD D:\____Software\00.Mygithub_web\blog\HACV</code>，目录不会切换<br>但在下次输入盘符的时候进入上一次希望进入的目录，如输入<code>D：</code>会直接进入<code>D:\____Software\00.Mygithub_web\blog\HACV</code></p><h3 id="《3》CMD进入带有空格的文件夹"><a href="#《3》CMD进入带有空格的文件夹" class="headerlink" title="《3》CMD进入带有空格的文件夹"></a>《3》CMD进入带有空格的文件夹</h3><p>注：查看带有空格的文件夹（如Documents and settings，Program files等文件夹）<br>有下面两种处理方法：</p><blockquote><ul><li><strong>给文件夹加引号</strong>。如C磁盘<code>cd c:\"documents and settings"</code><br>这样的好处是多长的文件名都可以全部显示出来。</li><li>由于一般情况下DOS系统只支持8.3格式的文件名，因此在DOS下遇到长文件名的文件夹时，<strong>取前面6位</strong>，然后在后面加上一个<code>~</code>号和数字<code>1</code>。 你可以输入C:/&gt; <code>cd c:/docume~1</code> 进入<code>Documents and settings</code>文件夹。当截取前面的6个字母之后出现重复时，可以将1改为2，依此类推。</li></ul></blockquote><h2 id="四、C语言中编程建议"><a href="#四、C语言中编程建议" class="headerlink" title="四、C语言中编程建议"></a>四、C语言中编程建议</h2><pre class=" language-c"><code class="language-c">FILE <span class="token operator">*</span> fp<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//文件名可以有两种写法 </span><span class="token comment" spellcheck="true">//方法1）char *filename="f:\\1.txt";</span><span class="token keyword">char</span> <span class="token operator">*</span>filename2<span class="token operator">=</span><span class="token string">"f:/test.txt"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//写法2）</span><span class="token comment" spellcheck="true">//记住，我们以后写代码，统一用这种45度的 </span><span class="token comment" spellcheck="true">//原因：45度在Linux下，Windows下通用</span><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">27</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"123456\n"</span><span class="token punctuation">,</span><span class="token string">"234555\n"</span><span class="token punctuation">,</span><span class="token string">"KKKKK"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">char</span> tt<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>filename2<span class="token punctuation">,</span><span class="token string">"wb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><font style="background: yellow" size="5">以后写代码，统一用这种45度的（也就是Linux那种）</font><br>原因：C语言中45度在Linux下，Windows下通用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmd命令 </tag>
            
            <tag> Windows效率 </tag>
            
            <tag> Linux效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmd运行命令</title>
      <link href="/2020/06/14/2020-06-14-Run-command/"/>
      <url>/2020/06/14/2020-06-14-Run-command/</url>
      
        <content type="html"><![CDATA[<h1 id="电脑运行命令集锦"><a href="#电脑运行命令集锦" class="headerlink" title="电脑运行命令集锦"></a>电脑运行命令集锦</h1><p>win+R，在『运行』窗口中输入</p><p>cmd————CMD命令提示符 </p><h2 id="一、自己常用"><a href="#一、自己常用" class="headerlink" title="一、自己常用"></a>一、自己常用</h2><blockquote><ul><li>calc———–启动计算器 （写代码的时候，可以快速看二进制）</li><li>mspaint——–画图板 （可以画讲解图,博客和数位板用）</li></ul></blockquote><blockquote><ul><li>regedit——–注册表（编辑器） </li><li>regedt32——-注册表编辑器（同上）</li><li>firewall.cpl—WINDOWS防火墙 </li><li>control——–打开控制面板 </li><li>lusrmgr.msc—-本机用户和组<br>（win10可以不用这个来管理）</li><li>gpedit.msc—–组策略（？） </li></ul></blockquote><blockquote><ul><li>notepad——–打开记事本（有时候用）</li><li>write———-写字板（就是rtf格式的那种文件）</li><li>wordpad——–写字板 （和上面一样，冗余的）</li></ul></blockquote><h2 id="二、管理电脑系统"><a href="#二、管理电脑系统" class="headerlink" title="二、管理电脑系统"></a>二、管理电脑系统</h2><p>utilman——–辅助工具管理器 （比如调整键盘映射？？？）</p><h3 id="《1》系统"><a href="#《1》系统" class="headerlink" title="《1》系统"></a>《1》系统</h3><blockquote><ul><li><font size="5"><code>.</code></font>————–打开<font size="5">当前用户名</font>所在文件夹 （比如本用户的各种快速访问）</li><li><code>..</code>————-打开<font size="5">所有用户</font>所在文件夹（比如，你用Windows电脑的<font size="5">多用户功能</font>的时候）</li><li><code>...</code>————我的电脑 </li></ul></blockquote><p><code>\</code>————–C盘</p><blockquote><ul><li>%temp%———打开临时文件夹 </li><li>desk.cpl——-显示器属性（屏幕分辨率） </li><li>fsmgmt.msc—–共享文件夹管理器 </li></ul></blockquote><p>explorer——-打开资源管理器<br>（个人习惯用win+E快捷键,更好一些）</p><h3 id="《2》网络"><a href="#《2》网络" class="headerlink" title="《2》网络"></a>《2》网络</h3><blockquote><ul><li>ncpa.cpl——-网络连接（比如，我的无线等网络各种的设置） </li><li>nslookup——-IP地址侦测器 ——-网络管理的工具向导<br>iexpress——-网络安全工具，似乎可以木马捆绑工具，系统自带 111<br>inetcpl.cpl—-INTETNET选项 （打开了Internet属性）<br>mstsc———-远程桌面连接 </li></ul></blockquote><h3 id="《3》硬件"><a href="#《3》硬件" class="headerlink" title="《3》硬件"></a>《3》硬件</h3><blockquote><ul><li>hdwwiz.cpl—–添加硬件（打开了设备管理器）<br>devmgmt.msc—-设备管理器 </li></ul></blockquote><p>taskmgr——–任务管理器 （我用快捷键更加快？）（2000／xp／2003我的Windows10也OK</p><h3 id="《4》多媒体"><a href="#《4》多媒体" class="headerlink" title="《4》多媒体"></a>《4》多媒体</h3><p>dvdplay——–DVD播放器<br>mplayer2——-简易widnowsmediaplayer （同上）</p><p>mplayer2——-简易widnows media player<br>mplayer2——-媒体播放机</p><p>mmsys.cpl——声音和音频设备 （设置声音，那些什么立体，也就是录制的是麦还是电脑本身）<br>main.cpl——-鼠标 </p><p>magnify——–放大镜实用程序<br>narrator——-屏幕“讲述人”<br>（讲出来）<br>osk————打开屏幕键盘 </p><h2 id="三、不大常用"><a href="#三、不大常用" class="headerlink" title="三、不大常用"></a>三、不大常用</h2><p>winver———检查Windows版本 </p><p>compmgmt.msc—计算机管理<br>odbcad32——-ODBC数据源管理器<br>C:/windows/fonts字体</p><h2 id="四、未强化"><a href="#四、未强化" class="headerlink" title="四、未强化"></a>四、未强化</h2><p>certmgr.msc—-证书管理实用程序（不知道干啥用）<br>cliconfg——-SQL SERVER（Windows公司的那个数据库） 客户端网络实用程序</p><p>intl.cpl——-区域和语言选项（输入法选项）<br>eventvwr——-一个事情查看器<br>eudcedit——-造字程序<br>cleanmgr——-（磁盘）垃圾整理<br>diskmgmt.msc—磁盘管理实用程序<br>chkdsk.exe—–Chkdsk磁盘检查 （可能要谨慎使用）<br>charmap——–启动字符映射表<br>dcomcnfg——-打开系统组件服务<br>dxdiag———检查DirectX信息<br>irprops.cpl—-无线链接<br>（打开了红外线，。。。）<br>joy.cpl——–游戏控制器<br>migwiz———文件转移向导<br>msconfig.exe—系统配置实用程序<br>mmc————打开控制台<br>mobsync——–同步命令<br>perfmon.msc—-计算机性能监测程序<br>powercfg.cpl—电源选项<br>rsop.msc——-组策略结果集<br>sysdm.cpl——系统<br>timedate.cpl—日期和时间<br>services.msc—本地服务设置<br>sigverif——-文件签名验证程序<br>shrpubw——–共享文件夹设置工具<br>sfc.exe——–系统文件检查器<br>（不知道是啥？框框一闪而过）<br>telephon.cpl—电话和调制解调器选项<br>sfc /scannow—–扫描错误并复原<br>wmimgmt.msc—-打开windows管理体系结构(WMI)<br>wscript——–windows脚本宿主设置<br>wscui.cpl——安全中心<br>wiaacmgr——-扫描仪和照相机向导<br>（要安装了扫描仪或照相机才有用）<br>net start messenger—-开始信使服务<br>net stop messenger—–停止信使服务<br><b>（测试完后，鼠标就消失了？当时环境我连接了VPN（oobe/msoobe/a-检查XP是否激活(罪魁祸首) ）</b></p><h2 id="五、未测试的"><a href="#五、未测试的" class="headerlink" title="五、未测试的"></a>五、未测试的</h2><p>logoff———注销命令（？）<br>netstartX—-开始X服务 （–未测试）<br>netstopX—–停止X服务 （–未测试）<br>syskey———系统加密（一旦加密就不能解开，保护windowsxp系统的双重密码）<br>（谨慎使用—未测试）<br>shutdown——-关机命令（详细请在cmd中输入shutdown/?）<br>（—未测试）<br><code>regsvr32 /u *.dll</code>—-停止dll文件运行<br><code>regsvr32 /u zipfldr.dll</code>——取消ZIP支持<br><code>regsvr32/?</code>—-调用、卸载DLL文件运行（详细请在cmd中输入regsvr32/?）<br>（谨慎使用！）<br>syncapp——–创建一个公文包<br>（–未测试）<br>wuaucpl.cpl—-自动更新（–未测试）<br>wupdmgr—–windows更新程序（–未测试）<br>tsshutdn——-60秒倒计时关机命令<br>rononce -p —-15秒关机<br>sfc /scannow—windows文件保护<br>netstat -an—-（TC）命令检查接口</p><h2 id="六、Windows10，本电脑测试不通过的"><a href="#六、Windows10，本电脑测试不通过的" class="headerlink" title="六、Windows10，本电脑测试不通过的"></a>六、Windows10，本电脑测试不通过的</h2><p>conf———–启动netmeeting （？）（Conf听说在局域网用）<br>drwtsn32—— 系统医生（？）<br>Sndvol32——-音量控制程序<br>ciadv.msc——索引服务程序<br>clipbrd——–剪贴板查看器（？）<br>appwize.cpl—-添加、删除程序 （？）<br>access.cpl—–辅助功能选项（？）<br>Accwiz———辅助功能向导（？）<br>cintsetp——-仓颉拼音输入法（？）<br>ciadv.msc——索引服务程序（？）<br>ddeshare——-打开DDE共享设置（？）<br>drwtsn32——-系统医生（？）<br>dfrg.msc——-磁盘碎片整理程序（？）<br>mem.exe——–显示内存使用情况（？）<br>mlcfg32.cpl—-邮件 （？）<br>netstat-an—-命令检查接口（？）<br>netsetup.cpl—无线网络安装向导（？）<br>ntbackup——-系统备份和还原（？）<br>ntmsmgr.msc—-移动存储管理器（？）<br>ntmsoprq.msc—移动存储管理员操作请求（？）<br>nusrmgr.cpl—-用户账户（？）<br>nwc.cpl——–NetWare客户服务（？）<br>oobe/msoobe/a-检查XP是否激活(?)<br>packager——-对象包装程序（？）<br>progman——–程序管理器（？）<br>sndrec32——-录音机（？）<br>sndvol32——-音量控制程序（？）<br>sapi.cpl——-语音（？）<br>sysedit——–系统配置编辑器（？）<br>secpol.msc—–本地安全策略（？）<br>sfc/scannow—windows文件保护（？）<br>tourstart——xp简介（安装完成后出现的漫游xp程序）（？）<br>winmsd———系统信息（？）<br>telnet———远程连接程序（？）<br>winchat——–XP自带局域网聊天（？） </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmd命令 </tag>
            
            <tag> Windows效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo命令</title>
      <link href="/2020/06/14/2020-06-14-Hexo/"/>
      <url>/2020/06/14/2020-06-14-Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h1><blockquote><ul><li>hexo clean  清除缓存文件<code>db.json</code> 和已生成的静态文件<code>public</code><blockquote><ul><li>网站显示异常时可以执行这条命令试试,比如，网站的标签和分类没有及时更新</li></ul></blockquote></li><li>hexo g &amp;&amp; hexo s -p 5555   用本地的555端口，进行本地调试</li><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d    上传到github</li></ul></blockquote><blockquote><ul><li>hexo new page “tags”    新建标签</li></ul></blockquote><blockquote><ul><li>hexo new test    新建一篇博客，名字叫test.md</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL强化</title>
      <link href="/2020/06/13/2020-06-13-STL/"/>
      <url>/2020/06/13/2020-06-13-STL/</url>
      
        <content type="html"><![CDATA[<h1 id="STL整理"><a href="#STL整理" class="headerlink" title="STL整理"></a>STL整理</h1><blockquote><ul><li>类模板 </li><li>函数模板</li><li>数据结构</li><li>算法</li><li>封装</li></ul></blockquote><h2 id="（1）-include-lt-vector-gt"><a href="#（1）-include-lt-vector-gt" class="headerlink" title="（1）#include<vector>"></a>（1）#include&lt;vector&gt;</h2><p>可变长数组<br>底层实现是数组<br>具体可以看清华邓俊辉的</p><h2 id="（2）-include-lt-set-gt"><a href="#（2）-include-lt-set-gt" class="headerlink" title="（2）#include<set>"></a>（2）#include&lt;set&gt;</h2><p>集合<br>内部自动有序<br>并且不含重复元素的容器，也就是会去重。</p><p>内部实现是<strong>红黑树</strong></p><h3 id="（1）multiset"><a href="#（1）multiset" class="headerlink" title="（1）multiset"></a>（1）multiset</h3><blockquote><p>set中元素是唯一的。<br>而我的这个的元素不是唯一的。<br>也就是元素没有去重。</p></blockquote><p>样例：</p><pre class=" language-txt"><code class="language-txt">输入一个长度不超过20的字符串，对所输入的字符串，按照ASCII码的大小从小到大进行排序，请输出排序后的结果</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    multiset<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要是用set，则去重了，不行baca这样子的</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        st<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>multiset<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> it<span class="token operator">!=</span>st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="（2）unordered-set"><a href="#（2）unordered-set" class="headerlink" title="（2）unordered_set"></a>（2）unordered_set</h3><p><font color="red" size="5">C++11标准中添加的</font></p><blockquote><p>可以用来处理只去重复，但是不排序<br>内部实现是散列（hash）</p></blockquote><h2 id="（3）-include-lt-string-gt"><a href="#（3）-include-lt-string-gt" class="headerlink" title="（3）#include<string>"></a>（3）#include&lt;string&gt;</h2><h2 id="（4）-include-lt-map-gt"><a href="#（4）-include-lt-map-gt" class="headerlink" title="（4）#include<map>"></a>（4）#include&lt;map&gt;</h2><p>映射</p><p>可以将任何基本类型和STL容器，映射到任何基本类型和STL容器</p><p>注意，map中的键和值是唯一的</p><p>内部实现是<strong>红黑树</strong></p><h3 id="（1）multimap"><a href="#（1）multimap" class="headerlink" title="（1）multimap"></a>（1）multimap</h3><blockquote><p>一个键对应多个值</p></blockquote><h3 id="（2）unordered-map"><a href="#（2）unordered-map" class="headerlink" title="（2）unordered_map"></a>（2）unordered_map</h3><p><font color="red" size="5">C++11标准中添加的</font></p><blockquote><p>底层实现是散列（hash）</p></blockquote><h2 id="（5）-include-lt-queue-gt"><a href="#（5）-include-lt-queue-gt" class="headerlink" title="（5）#include<queue>"></a>（5）#include&lt;queue&gt;</h2><p>队列</p><h3 id="（1）deque"><a href="#（1）deque" class="headerlink" title="（1）deque"></a>（1）deque</h3><blockquote><p>双端队列。双向队列</p></blockquote><h3 id="（2）priority-queue"><a href="#（2）priority-queue" class="headerlink" title="（2）priority_queue"></a>（2）priority_queue</h3><blockquote><p><code>include&lt;queue&gt;</code>就可以用优先队列<br>优先队列<br>用堆实现的<strong>默认</strong>将当前队列<strong>最大元素</strong>置于队首的容器</p></blockquote><h2 id="（6）-include-lt-stack-gt"><a href="#（6）-include-lt-stack-gt" class="headerlink" title="（6）#include<stack>"></a>（6）#include&lt;stack&gt;</h2><h2 id="（7）pair"><a href="#（7）pair" class="headerlink" title="（7）pair"></a>（7）pair</h2><p>（使）成对<br><code>#include&lt;utility&gt;</code>才能使用（奇奇怪怪）</p><p>注意，map内部实现涉及到了pair,所以，要是我们<br><code>#include&lt;map&gt;</code><br>那么我们要是想要使用pair，就不用另外<code>#include&lt;utility&gt;</code>了</p><h2 id="（8）-include-lt-list-gt"><a href="#（8）-include-lt-list-gt" class="headerlink" title="（8）#include<list>"></a>（8）#include&lt;list&gt;</h2><p>双向链表</p><h2 id="（9）-include-lt-bitset-gt"><a href="#（9）-include-lt-bitset-gt" class="headerlink" title="（9）#include<bitset>"></a>（9）#include&lt;bitset&gt;</h2><p>若干个位</p><h2 id="（10）-include-lt-algorithm-gt"><a href="#（10）-include-lt-algorithm-gt" class="headerlink" title="（10）#include<algorithm>"></a>（10）#include&lt;algorithm&gt;</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柔性数组（Flexible Array）</title>
      <link href="/2020/06/12/2020-06-12-Flexible-Array/"/>
      <url>/2020/06/12/2020-06-12-Flexible-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="柔性数组（可变长数组）"><a href="#柔性数组（可变长数组）" class="headerlink" title="柔性数组（可变长数组）"></a>柔性数组（可变长数组）</h1><h2 id="一、观察现象"><a href="#一、观察现象" class="headerlink" title="一、观察现象"></a>一、观察现象</h2><h3 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list_t<span class="token punctuation">{</span>    <span class="token keyword">struct</span> list_t <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_t <span class="token operator">*</span>prev<span class="token punctuation">;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>list_t<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>测试环境：32位，DevC++5.11的C语言编译器<br>输出：8<br>测试环境：32位，VS2012的C语言编译器<br>输出：8</p></blockquote><h3 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h3><p>将测试1中代码，<code>char data[0];</code>改为<code>char data[];</code></p><blockquote><p>测试环境：32位，DevC++5.11的C语言编译器<br>输出：8<br>测试环境：32位，VS2012的C语言编译器<br>输出：8</p></blockquote><br>柔性数组解释：这是因为在定义这个结构体的时候，结构体的大小已经不包含柔性数组的内存大小了。  <b>柔性数组不占结构体内</b>。只是在使用的时候需要把它当作结构体的一个成员而已。<br>（这个说法，让我想起了C++类中的static变量，本质是全局变量，所以其实不占那个类的内存，但是我把它放在类里面只是为了告知，这个变量和这个类有联系）<h2 id="二、编译器支持情况"><a href="#二、编译器支持情况" class="headerlink" title="二、编译器支持情况"></a>二、编译器支持情况</h2><blockquote><ul><li>柔性数组（Flexible Array）是<strong>C99</strong>引入的一个新特性</li><li>这个特性允许你在定义结构体的时候创建一个<strong>空数组</strong>，而这个数组的大小可以在程序运行的过程中<strong>根据你的需求进行更改</strong>（也就是可变长长度的数组），这样我们在结构体中定义一个柔性数组，这样可以确保能够在程序运行过程中“动态”的进行结构体的扩展！<blockquote><ul><li>特别注意：<blockquote><ul><li>1）<font style="background: yellow">这个空数组必须声明为结构体的<strong>最后一个</strong>成员</font></li><font style="background: yellow"></font><li><font style="background: yellow">2）并且还要求这样的结构体<strong>至少</strong>包含一个<strong>其他类型</strong>的成员</font></li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><p>PS——摘自别人的注解：</p><blockquote><p>1）其实，C99支持的标准是<code>char address[]</code>,按理来说<code>char address[0]</code>是非法的，只不过，有的编译器把它当做非标准扩展了。<br>2）此外，在C99之前，就有这样的写法，C99出来后，有些编译器把两者等同了。</p></blockquote><p>所以，我才能在32位，<strong>DevC++5.11的C语言编译器（支持的是C89）</strong>这样的测试环境下，还能使用这种写法。</p><p>此外，在很多编译器中，对这个的支持有点差异，具体使用，还是测试一下吧。    虽然，似乎很多版本gcc是OK的</p><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">//存放学生信息结构体</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> stuID<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> address<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ST_STU_INFO<span class="token punctuation">,</span><span class="token operator">*</span>pStuInfo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为结构体分配内存</span>pStuInfo <span class="token function">ComposeStuInfo</span><span class="token punctuation">(</span> <span class="token keyword">int</span> stuID<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>paddress<span class="token punctuation">)</span><span class="token punctuation">{</span>    pStuInfo ptmpInfo <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ptmpInfo<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">strlen</span><span class="token punctuation">(</span>paddress<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptmpInfo <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ptmpInfo<span class="token operator">-></span>stuID <span class="token operator">=</span> stuID<span class="token punctuation">;</span>        ptmpInfo<span class="token operator">-></span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>ptmpInfo<span class="token operator">-></span>address<span class="token punctuation">,</span> paddress<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ptmpInfo<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 打印学生信息</span><span class="token keyword">void</span> <span class="token function">printStuInfo</span><span class="token punctuation">(</span>pStuInfo ptmpInfo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stuID : %d   age : %d   Address: %s\nSize of Struct：%d\n\n"</span><span class="token punctuation">,</span>            ptmpInfo<span class="token operator">-></span>stuID<span class="token punctuation">,</span>ptmpInfo<span class="token operator">-></span>age<span class="token punctuation">,</span>ptmpInfo<span class="token operator">-></span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ptmpInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//主程序</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pStuInfo CodeLab <span class="token operator">=</span> <span class="token function">ComposeStuInfo</span><span class="token punctuation">(</span><span class="token number">100013</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"Tencent,Shenzhen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>CodeLab <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printStuInfo</span><span class="token punctuation">(</span>CodeLab<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>CodeLab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pStuInfo subCodeLab <span class="token operator">=</span> <span class="token function">ComposeStuInfo</span><span class="token punctuation">(</span><span class="token number">200013</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">"Tencent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>subCodeLab <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printStuInfo</span><span class="token punctuation">(</span>subCodeLab<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>subCodeLab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出如下：</p><pre class=" language-c"><code class="language-c">stuID <span class="token punctuation">:</span> <span class="token number">100013</span>   age <span class="token punctuation">:</span> <span class="token number">20</span>   Address<span class="token punctuation">:</span> Tencent<span class="token punctuation">,</span>ShenzhenSize of Struct：<span class="token number">8</span>stuID <span class="token punctuation">:</span> <span class="token number">200013</span>   age <span class="token punctuation">:</span> <span class="token number">23</span>   Address<span class="token punctuation">:</span> TencentSize of Struct：<span class="token number">8</span></code></pre><p>分析：<br>1）用柔性数组，我们成功实现了用不同长度的数组，而程序不会由于越界等异常情况而崩溃<br>2）并且，在输出中，我们可以看到结构体的大小并没有因此而发生变化。</p><p>所以来看一道<b>“美团点评”</b>的笔试题：</p><pre class=" language-c"><code class="language-c">开发C代码时<span class="token punctuation">,</span>经常见到如下类型的结构体定义<span class="token punctuation">:</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list_t<span class="token punctuation">{</span> <span class="token keyword">struct</span> list_t <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token keyword">struct</span> list_t <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>list_t<span class="token punctuation">;</span>最后一行<span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>的作用是（）A、方便管理内存缓冲区B、减少内存碎片化C、标识结构体结束D、没有作用</code></pre><p>答案是：A和B<br>1）针对柔性数组这一不占用内存的特性，可以构造出内存缓冲区，同时由于是使用多少就申请多少，也起到了减少内存碎片化的作用，所以答案是A和B<br>2）C选项，柔性数组并不是标识结构体结束，而是作为结构体的一种拓展<br>3）注意:构造缓冲区就是方便管理内存缓冲区,减少内存碎片化。</p><h2 id="四、对比"><a href="#四、对比" class="headerlink" title="四、对比"></a>四、对比</h2><h3 id="直接使用指针"><a href="#直接使用指针" class="headerlink" title="//直接使用指针"></a>//直接使用指针</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> stuID<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pAddress<span class="token punctuation">;</span><span class="token punctuation">}</span>ST_STU_INFO<span class="token punctuation">;</span></code></pre><h3 id="使用固定长度大小的数组"><a href="#使用固定长度大小的数组" class="headerlink" title="//使用固定长度大小的数组"></a>//使用固定长度大小的数组</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> stuID<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> pAddress<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ST_STU_INFO<span class="token punctuation">;</span></code></pre><h3 id="使用柔性数组"><a href="#使用柔性数组" class="headerlink" title="//使用柔性数组"></a>//使用柔性数组</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> stuID<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> pAddress<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ST_STU_INFO<span class="token punctuation">;</span></code></pre><p><strong>对比：</strong><br>1）柔性数组不占用内存，而指针则不然，柔性数组在使用上是直接访问，形式上更加直观，而指针需要经过声明再进行动态分配内存，在效率上和柔性数组相比也稍微低一些。<br>2）柔性数组能够按需用内存，而固定长度的数组，由于可能用不了那么长就会导致浪费。要是用的超过固定长度，则会导致程序崩溃。比如下面这样:<br><img src="https://github.com/HACV/Blog_Gallery/blob/master/2020/2020_6/2020_06_12_1.gif?raw=true" width="80%"></p><h2 id="五、设计初衷和用途"><a href="#五、设计初衷和用途" class="headerlink" title="五、设计初衷和用途"></a>五、设计初衷和用途</h2><p>Tips：在<strong>Linux内核代码</strong>中有较多的柔性数组的使用</p><p><strong>设计初衷</strong>：主要用途是为了满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题</p><p><strong>用途</strong>：</p><blockquote><ul><li>1）这样的变长数组常用于网络通信中构造<strong>不定长数据包</strong>，不会浪费空间浪费网络流量，比如我要发送1024字节的数据，如果用定长包，假设定长包的长度为2048，就会浪费1024个字节的空间，造成不必要的流量浪费。</li><li>2）<strong>跳跃表（跳表，Skip list）</strong>的实现上，可以使用柔性数组。</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自用Markdown语法</title>
      <link href="/2020/06/11/2020-06-11-Markdown/"/>
      <url>/2020/06/11/2020-06-11-Markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="一、重视快捷键，重视工具"><a href="#一、重视快捷键，重视工具" class="headerlink" title="一、重视快捷键，重视工具"></a>一、重视快捷键，重视工具</h2><p>一定要重视工具的使用，对于常用的工具，要观察好自己的使用习惯，积累自己使用的定制方案<br>:smile::smile::smile:</p><h2 id="二、自己常用的Markdown的语法"><a href="#二、自己常用的Markdown的语法" class="headerlink" title="二、自己常用的Markdown的语法"></a>二、自己常用的Markdown的语法</h2><blockquote><ul><li>粗体 <code>** **</code>  （三者都支持）    Ctrl+B（快捷键）<blockquote><ul><li>粗体 <code>&lt;b&gt; &lt;/b&gt;</code>（三者都支持）</li></ul></blockquote></li><li>字体颜色<code>&lt;font color="red"&gt;   &lt;/font&gt;</code> <font color="red">字体颜色</font></li><li>字体大小<code>&lt;font size=5&gt;    &lt;/font&gt;</code><font size="6">字体大小</font></li><li>字体类型<code>&lt;font face="行书" size=5&gt;  &lt;/font&gt;</code><font face="楷书" size="5">字体类型</font></li><li>字体背景颜色<code>&lt;font style="background: red"&gt;红色&lt;/font&gt;&lt;br&gt;</code><font style="background: red">字体背景颜色</font></li><li>插入图片和大小<code>&lt;img src="../photos/2020.6.03_15/2020_06_08_1.png" width="80%"&gt;</code></li><li>加个换行<code>&lt;br&gt;</code></li></ul></blockquote><blockquote><ul><li>Markdown一个套兼容HTML的语法，所以使用HTML中下标下标的语法即可。<blockquote><ul><li>上标<code>&lt;sup&gt;&lt;/sup&gt;</code>2<sup>32</sup></li><li>下标<code>&lt;sub&gt;&lt;/sub&gt;</code>H<sub>2</sub>O</li></ul></blockquote></li><li>表格的底色<code>&lt;table&gt;&lt;td bgcolor=#FFFF FF&gt;&lt;/td&gt;&lt;/table&gt;</code></li></ul></blockquote><p>md原生表格</p><p>语法</p><p><code>| 水果        | 价格    |  数量  |</code><br><code>| ---           | ---   | --- |</code><br><code>| 香蕉        | 1      |   5    |</code><br><code>| 苹果        | 1      |   6    |</code><br><code>| 草莓        | 1      |   7    |</code></p><table><thead><tr><th>水果</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>香蕉</td><td>1</td><td>5</td></tr><tr><td>苹果</td><td>1</td><td>6</td></tr><tr><td>草莓</td><td>1</td><td>7</td></tr></tbody></table><h3 id="三、Haroopad上Markdown常用快捷键"><a href="#三、Haroopad上Markdown常用快捷键" class="headerlink" title="三、Haroopad上Markdown常用快捷键"></a>三、Haroopad上Markdown常用快捷键</h3><blockquote><ul><li>ALt+左方向        跳到行最左边</li><li>ALt+右方向         跳到行最右左边</li><li>Ctrl+K          将选中的添加行内代码标记</li><li>Ctrl+Shift+Q      在选中的行前面添加<code>&gt;</code></li><li>Ctrl+shift+J  添加行内<strong>数学公式</strong>  但是3个<code>$$$</code>什么鬼(注意，<strong>hexo中的数学公式则只支持一个$</strong>)</li></ul></blockquote><h3 id="四、数学公式（markdown支持latex）"><a href="#四、数学公式（markdown支持latex）" class="headerlink" title="四、数学公式（markdown支持latex）"></a>四、数学公式（markdown支持latex）</h3><p>以后，或许用于写论文？<br>:smile::smile::smile:</p><p><code>$C_{下面}^{上面}$</code>  比如$C_{2n}^{n}$<br><code>$\infty$</code> 就是$\infty$<br><code>$\frac{分子}{分母}$</code>  比如$\frac{i}{n}$</p><h3 id="五、安装emoji"><a href="#五、安装emoji" class="headerlink" title="五、安装emoji"></a>五、安装emoji</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis --save</code></pre><p>Add configuration of <code>_config.yml</code> file in Hexo root folder as follows：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span></code></pre><p>然后就可以<br><code>:smile::smile::smile:</code><br><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程杂谈</title>
      <link href="/2020/06/11/2020-06-11-The-concept-of-Process-and-Thread/"/>
      <url>/2020/06/11/2020-06-11-The-concept-of-Process-and-Thread/</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程中的同步机制"><a href="#进程和线程中的同步机制" class="headerlink" title="进程和线程中的同步机制"></a>进程和线程中的同步机制</h1><p><b>进程</b>是<b>资源管理</b>的最小单位<br><b>线程</b>是<b>程序执行</b>的最小单位。<br>记忆方法：<br><font style="background: yellow">大Boss（进程），只管拿着资源统筹兼顾。<br>小兵（线程），要卖力执行命令。</font></p><h2 id="一、进程和线程在两大操作系统的特点"><a href="#一、进程和线程在两大操作系统的特点" class="headerlink" title="一、进程和线程在两大操作系统的特点"></a>一、进程和线程在两大操作系统的特点</h2><blockquote><ul><li>Windows对进程和线程的实现如同教科书一般标准。<blockquote><ul><li><font style="background: yellow">Windows内核中有明确的<b>进程</b>和<b>线程</b>的概念</font></li></ul></blockquote></li><li>Linux内核中<b>并不存在真正意义上</b>的<b>线程</b>的概念<blockquote><ul><li>Linux将所有的执行实体（无论是进程还是线程）都称为<font style="background: yellow"><b>任务（Task）</b></font></li><li><b>每个Task概念上都类似于一个单线程的进程</b>，具有内存空间、执行实体、文件资源等。</li><li>不过,<b>Linux下不同的任务之间可以选择共享内存空间</b>，因而在实际意义上，共享了同一个内存空间的多个任务构成了一个进程， 这些任务也就成了这个进程里的线程。<blockquote><ul><li>Linux下的线程本质上用进程实现;（题目）</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><h2 id="二、线程安全"><a href="#二、线程安全" class="headerlink" title="二、线程安全"></a>二、线程安全</h2><p><font color="red" size="5">（记得到时候加上代码）</font><br>为了避免多个线程同时读写同一个数据而产生不可预料的后果,我们需要将各个线程对同一个数据的访问同步(Synchronization)。<br>所谓同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。</p><h3 id="同步的常见方法："><a href="#同步的常见方法：" class="headerlink" title="同步的常见方法："></a>同步的常见方法：</h3><blockquote><ul><li><font style="background: yellow" type="楷体" size="5">（1）</font>同步的<b>最常见方法</b>是使用<b>锁（Lock）</b>。锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。<blockquote><ul><li><font style="background: yellow"><b>（严格程度：低）二元信号量（Binary Semaphore）</b></font><b>是最简单的一种锁</b>，它只有两种状态:占用与非占用。它适合只能被唯一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。</li><li>对于<b>允许多个线程并发访问</b>的资源，<b>多元信号量简称信号量(Semaphore)</b>,它是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源的时候首先获取信号量，进行如下操作:<blockquote><ul><li>将信号量的值减1。</li><li>如果信号量的值小于0，则进入等待状态，否则继续执行。</li></ul></blockquote></li><li>访问完资源之后，线程释放信号量，进行如下操作:<blockquote><ul><li>将信号量的值加1。</li><li>如果信号量的值小于1,唤醒-一个等待中的线程。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><blockquote><ul><li><font style="background: yellow"><b>（严格程度：中）互斥量（Mutex）</b></font>和<b>二元信号量</b>很类似，资源仅同时允许一个线程访问，但和信号量不同的是:<blockquote><ul><li>1）<b>信号量</b>在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后的<font style="background: yellow">另一个线程</font>释放。</li><li>2）<b>互斥量</b>则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁，其他线程越俎代庖去释放互斥量是无效的。</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li><font style="background: yellow"><b>（严格程度：高）临界区（Critical Section）</b></font>是比<b>互斥量</b>更加严格的同步手段。<blockquote><ul><li>在术语中，把临界区的锁的获取称为进入临界区,而把锁的程放称为离开临界区。</li><li>临界区和互斥量与信号量的区别在于:<blockquote><ul><li>1）<b>互斥量和信号量</b>在系统的<font style="background: yellow"><b>任何进程</b></font>里都是可见的，也就是说，一个进程创建了一个互斥量或信号量,另一个进程试图去获取该锁是合法的。</li><li>2）<b>临界区</b>的作用范围<font style="background: yellow"><b>仅限于本进程</b></font>，其他的进程无法获取该锁。除此之外，临界区具有和互斥量相同的性质。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><blockquote><ul><li><font style="background: yellow" type="楷体" size="5">（2）</font><font style="background: yellow"><b>读写锁（Read-Write Lock）</b></font><blockquote><ul><li>由来：对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个数据进行修改，就必须使用同步手段来避免出错。如果我们使用上述信号量、互斥量或临界区中的任何一种来进行同步，尽管可以保证程序正确，但<b>对于读取频繁，而仅仅偶尔写入的情况</b>，会显得非常低效。</li><li>读写锁(Read-Write Lock)致力于一种更加特定的场合的同步:<b>读取频繁，偶尔写入的情况</b></li><li>读写锁可以避免这个问题。对于同一个锁，读写锁有两种获取方式，<b>共享的(Shared)</b>或<b>独占(Exclusive)</b>。<blockquote><ul><li>当锁处于自由的状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。</li><li>如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。然而，如果其他线程试图以独身的方式获取已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。</li><li>相应地，处于独占状态的锁将阻止任何其他线程获取该锁，不论它们试图以哪种方式获取。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><blockquote><ul><li><font style="background: yellow" type="楷体" size="5">（3）</font><font style="background: yellow"><b>条件变量（Condition Variable）</b></font> 作为一种同步手段，作用类似于一个栅栏。<blockquote><ul><li>对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。</li><li>其次，线程可以唤醒条件变量,此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。也就是说，使用条件变量可以让许多线程-起等待某个事件的发生，当事件发生时(条件变量被唤醒)，所有的线程可以一起恢复执行。</li></ul></blockquote></li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程和线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共用体（联合）</title>
      <link href="/2020/06/10/2020-06-10-Union/"/>
      <url>/2020/06/10/2020-06-10-Union/</url>
      
        <content type="html"><![CDATA[<h1 id="共用体（联合）"><a href="#共用体（联合）" class="headerlink" title="共用体（联合）"></a>共用体（联合）</h1><h2 id="一、union"><a href="#一、union" class="headerlink" title="一、union"></a>一、union</h2><p>union中文翻译为“联合”（又称共用体）</p><blockquote><ul><li>吐槽——没事取这么多名字干啥……（好吧，其实是翻译，每个人有自己的翻译方式）<blockquote><ul><li>个人倾向于用共用体的名字，因为union共用内存的特点从名字就能直观的看出来，但是也有书上写成联合，所以，我也从各种地方搜集，发现一个还算说过过去的说明，叫“联合”显示union特点的解释。</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>联合：大家联合起来使用同一个空间</li></ul></blockquote><h2 id="二、union的特点"><a href="#二、union的特点" class="headerlink" title="二、union的特点"></a>二、union的特点</h2><p><b>特点</b>：使用同一个空间。（tips：共用体也有内存对齐！）<br>你用了，我就不能用了（除非你想使坏，把前面别人要用的给覆盖掉）。</p><p>PS:共用体，其实表明了计算机学科一个很重要的性质，那就是，其实数据都是0和1，至于为什么后面会有字符型，整型，图片，音频什么的，完全是对这些比特位的解释的不用导致的情况，所以，同样比特的可以解释是1首歌，也可以解释是一张图片（当然，需要你解释这些比特的算法正确）。</p><h2 id="三、常用场景"><a href="#三、常用场景" class="headerlink" title="三、常用场景"></a>三、常用场景</h2><blockquote><ul><li>1）这么节省内存，那嵌入式必须首先用起（要是两个不会同时使用的话。）</li><li>2）网络传输：通信中的数据包会用到共用体，因为不知道对方会发送一个什么过来，用共用体就简单了，定义几种格式的包，收到包之后就可以直接根据包的格式取出数据。</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位段__一种特殊的结构体</title>
      <link href="/2020/06/09/2020-06-09-Bit-Segment/"/>
      <url>/2020/06/09/2020-06-09-Bit-Segment/</url>
      
        <content type="html"><![CDATA[<h1 id="位段（也叫位域）"><a href="#位段（也叫位域）" class="headerlink" title="位段（也叫位域）"></a>位段（也叫位域）</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>我们在做单片机的时候。微控制单元（Microcontroller Unit；MCU），又称单片微型计算机（Single Chip Microcomputer ）或者单片机。<br>经常会告诉你第几个比特是什么什么叫停止比特啥的。<br>如何操作呢？后面的数字是说，这个成员占几个比特。<br>其实这种手法在C语言中的实现就可以用我们现在要讲的位段方式。当然，位段并不是这些偏底层的程序实现的唯一应用场景，我们还能将这些用于网络通信等。</p><h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> test    <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> c<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tt<span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>demo<span class="token punctuation">;</span></code></pre><p>特点：<br>编译器会安排其中的位的排列，不具有可移植性<br>当所需的位超过一个int时会采用多个int</p><h2 id="三、位段的特点和内存对齐"><a href="#三、位段的特点和内存对齐" class="headerlink" title="三、位段的特点和内存对齐"></a>三、位段的特点和内存对齐</h2><p>对于位域的定义，有以下几点说明：</p><blockquote><ul><li>（1）一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> wy<span class="token punctuation">{</span>   <span class="token keyword">unsigned</span> a<span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">;</span>   <span class="token keyword">unsigned</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//空域</span>   <span class="token keyword">unsigned</span> b<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//从一单元开始存放</span>   <span class="token keyword">unsigned</span> c<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在这个位域定义中，a占第一字节的6位，后2位填0表示不使用，</span><span class="token comment" spellcheck="true">//b从第二字节开始，占用4位，c占用4位。</span></code></pre><blockquote><ul><li>（2）由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是不能超过8位二进位。</li><li>（3）位域可以无位域名，这时它只用来填充或调整位置。无名的位域是不能使用的。</li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> wk<span class="token punctuation">{</span>   <span class="token keyword">int</span> a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> <span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//不能使用</span>   <span class="token keyword">int</span> b<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> c<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从以上述分析可以看出，位域可以看做是一种结构类型，其特点是成员均<b>按二进位分配</b>    。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="/2020/06/08/2020-06-08-Memory-Alignment/"/>
      <url>/2020/06/08/2020-06-08-Memory-Alignment/</url>
      
        <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="一、引例"><a href="#一、引例" class="headerlink" title="一、引例"></a>一、引例</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">char</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>demo<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出8不是5，表现了内存对齐</span></code></pre><p>原因:<font face="楷体" color="red" size="4">现代的计算机中，有一个内存对齐的要求</font></p><h2 id="二、说明"><a href="#二、说明" class="headerlink" title="二、说明"></a>二、说明</h2><p><b>PS：现代计算机中内存空间都是按照字节划分的，所以图示中一个黑色的长条代表一个字节。</b></p><p>例:有些平台<b>每次读都是从偶地址</b>开始的<br>如果一个int型（假设为32位系统）<br>1）如果他存放在<b>偶地址</b>开始的地方，那么一个CPU读的周期，就可以读出这个32bit的int</p><img src="/photos/2020.6.03_15/2020_06_08_1.png" width="90%"><p>2）如果他存放在<b>奇地址</b>开始的地方，那么我们要是想要读取，蓝色的部分的int，我们的CPU需要读两个红色的框框。在第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后将留下的两块数据合并放入寄存器。也就是说这种情况CPU需要2个读周期，并且对两次读出的结果的高低字节进行拼凑才能得到这个32位bit的数据。<br>很显然，这个在读取的效率上下降了很多。</p><img src="/photos/2020.6.03_15/2020_06_08_2.png" width="90%">此处肯定有疑惑<blockquote><ul><li>Q:难道就不能直接从那个奇地址开始读吗？</li><li>A:理论上讲，我们对任何类型的变量的访问可以从任何奇或者偶地址开始，这样是可以的。但是，我们的硬件在设计的时候，CPU的底层访问实现的似乎就是这个，每次从偶地址开始读取。</li></ul></blockquote><p>总的来说，内存对齐一般是由于以下原因：</p><blockquote><ul><li>1）<b>平台原因（移植原因）</b>：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。（有的硬件的设计就是只支持从偶地址开始访问的）</li><li>2）<b>性能原因（根本原因）</b>：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问（前面我们的例子就是这样）；而对齐的内存访问仅需要一次访问。<blockquote><ul><li>我们要提高CPU访问内存数据的<b>效率</b>的问题。</li><li>计算机访问内存一般是以内存块为单位的，块的大小是地址对齐的。如4,8,16字节对齐等。</li><li>一般来说对齐是跟CPU位数及CPU特性有关的，具体的比如X86-64支持1,2,4,8字节对齐.所以里面的讲的对齐主要还是取决于C语言中数据类型的大小。<br>PS：<b>对齐值必须是2的幂次方</b>，如1，2，4，8，16。如果一个变量按n字节对齐，那么该变量的起始地址必须是n的倍数。<br>每个<b>特定平台</b>上的编译器都有自己默认的“对齐系数”，可以通过设置<code>#pragma pack(n)</code>告诉编译器，是n字节对齐。</li></ul></blockquote></li></ul></blockquote><h2 id="三、内存对齐规则"><a href="#三、内存对齐规则" class="headerlink" title="三、内存对齐规则"></a>三、内存对齐规则</h2><p>（写的很混乱，，，，主要看例子体会吧）<br>Tips：C语言和C++允许你用预编译来干预内存对齐,比如用<code>#pragma pack</code>来干预。<br><font face="楷体" color="red" size="4">不同平台上编译器的 <code>pragma pack</code> 默认值不同。而我们可以通过预编译命令<code>#pragma pack(n)</code>, n= 1,2,4,8,16来改变对齐系数。</font><br>现代计算机读取数据的时候，都是一次性读取一个内存块，比如4字节。（更准确来说是与数据线根数有关）</p><table><tbody><tr><td bgcolor="#FFFF" ff="">一般<b>内存块</b>对齐方式：32位机器默认4字节对齐，64位机器默认8字节对齐</td></tr></tbody></table><blockquote><ul><li>规则1：<b>基本类型</b>的对齐值就是其sizeof获得值;（我们在进行基本类型对齐的同时，我们要尽量保证每个变量整体能放到1个或者2个内存块当中，并且要尽可能的小。（也就是能放在1个内存块，绝不放2个，否则会降低效率——比如先前图片中int放的位置。）</li><li>规则2：<b>结构(struct)和联合(union))的数据成员</b>对齐规则：第一个数据成员放在<b>offset（偏移量）</b>为0的地方。<blockquote><ul><li>1—<b>未改变默认规定对齐值</b>，则按照32位机器默认4字节对齐，64位机器默认8字节对齐。意思，就是要说结构体不满4字节（64位机器是8字节对齐），那么我们就要给他弄成这么多。</li><li>2—<b>修改了默认规定对齐值</b>，比如<code>#pragma pack</code>，那么<b>每个数据成员</b>的对齐按照<code>#pragma pack</code>指定的数值和这个数据成员sizeof的值中<b>小</b>的那个进行对齐。</li></ul></blockquote></li><li>规则3：<b>结构和联合整体</b>对齐规则：在数据成员完成各自对齐之后，结构和联合本身也要进行对齐。<blockquote><ul><li>1—<b>未改变默认规定对齐值</b>，对齐将按照结构或联合整体sizeof和默认的机器字节对齐中，比较小的那个进行;</li><li>2—<b>修改了默认规定对齐值</b>，比如<code>#pragma pack</code>，对齐将按照<code>#pragma pack</code>指定的数值和结构(或联合)sizeof获得值中<b>小</b>的那个进行;</li></ul></blockquote></li></ul></blockquote><h2 id="四、规则的应用"><a href="#四、规则的应用" class="headerlink" title="四、规则的应用"></a>四、规则的应用</h2><p>例1（规则1的应用）</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> b<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token operator">=</span><span class="token string">'c'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> d<span class="token operator">=</span><span class="token string">'d'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> e<span class="token operator">=</span><span class="token string">'e'</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> num<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>     <span class="token keyword">char</span> f<span class="token operator">=</span><span class="token string">'f'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//本程序在32位的编译环境测试的</span><span class="token comment" spellcheck="true">//62feaf</span><span class="token comment" spellcheck="true">//62feae</span><span class="token comment" spellcheck="true">//62fead</span><span class="token comment" spellcheck="true">//62feac</span><span class="token comment" spellcheck="true">//显然，上面按照变量在内存中栈的生长方向，是一个挨着一个放的，</span><span class="token comment" spellcheck="true">//而且char基本数据也符合1字节对齐（规则1）。</span><span class="token comment" spellcheck="true">//62feab</span><span class="token comment" spellcheck="true">//62fea0</span><span class="token comment" spellcheck="true">//从62feab按照常理应该是隔着（62fea省略）a 9 8 7 6 5 4 3八个字节，</span><span class="token comment" spellcheck="true">//也就是说最后赢输出62fea3而不是62fea0</span><span class="token comment" spellcheck="true">//那么，其中的那个多余的a 9 8三个字节的没有被利用，这就是被编译器进行了内存对齐，</span><span class="token comment" spellcheck="true">//为了访问数据方便</span><span class="token comment" spellcheck="true">//因为这样的话，前面那字符e和这3个字节也就能凑齐4个字节了。（规则1）</span><span class="token comment" spellcheck="true">//62fe9f</span></code></pre><p>例2（规则2和3的应用）：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span>demo1<span class="token punctuation">;</span><span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span><span class="token punctuation">}</span>demo2<span class="token punctuation">;</span><span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>demo3<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>demo1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>demo2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>demo3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//sizeof(c1)=1&lt;=4(32位系统默认的内存块对齐)</span><span class="token comment" spellcheck="true">//sizeof(i)=4&lt;=4</span><span class="token comment" spellcheck="true">//sizeof(c2)=1&lt;=4</span><span class="token comment" spellcheck="true">//本程序在32位的编译环境测试的</span><span class="token comment" spellcheck="true">//8    </span><span class="token comment" spellcheck="true">//第一个内存块（4个字节大小）正好可以放进int(占用offset=0-3),然后两个char分别(</span><span class="token comment" spellcheck="true">//占用offset=4和5)，根据规则3，整体要进行4字节对齐，所以，offset=6-7，我结构体也要占领，</span><span class="token comment" spellcheck="true">//虽然我也不用他，但就是不能给别人去占用。</span><span class="token comment" spellcheck="true">//12    </span><span class="token comment" spellcheck="true">//第一个内存块（4个字节大小）可以放进c1(占用offset=0),现在又要放int，</span><span class="token comment" spellcheck="true">//为了效率放(占用offset=4-7),下面又放char(占用offset=8),这样，我们目前占</span><span class="token comment" spellcheck="true">//用了9个字节。但是呢，根据规则3，整体要进行4字节对齐，所以，offset=9-11，</span><span class="token comment" spellcheck="true">//我结构体也要占领，虽然我也不用他，但就是不能给别人去占用。</span><span class="token comment" spellcheck="true">//8        </span><span class="token comment" spellcheck="true">//因为第一个内存块（4个字节大小）可以放进c1(占用offset=0),c2(占用offset=1),</span><span class="token comment" spellcheck="true">//但是后面发现我要是再放进一个int类型的前2个字节，那我以后CPU访问就要访问这个</span><span class="token comment" spellcheck="true">//内存块和下一个内存块，太没效率了。所以，我们将offset=2,3都空着，不用了。</span><span class="token comment" spellcheck="true">//我们将int放在下一个内存块中（4个字节大小），正好占用offset=4-7</span><span class="token comment" spellcheck="true">//所以整体用了2个内存块大小，也就是4*2=8字节</span></code></pre><p>例3：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> test<span class="token punctuation">{</span>     <span class="token keyword">int</span> ml<span class="token punctuation">;</span>    <span class="token keyword">char</span> m2<span class="token punctuation">;</span>    <span class="token keyword">float</span> m3<span class="token punctuation">;</span>    <span class="token keyword">union</span> uu    <span class="token punctuation">{</span>        <span class="token keyword">char</span> ul<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> u2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> ua<span class="token punctuation">;</span><span class="token punctuation">}</span> myaa<span class="token punctuation">;</span>问<span class="token number">32</span>位机器下<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> test <span class="token punctuation">)</span>答：<span class="token number">20</span></code></pre><p>解释：根据联合体的内存共用机制，显然union整体占用8个字节<br>int m1  4个<br>char m2 1个<br>float m3 4个<br>按照规则2和3，我们要按照默认的4字节对齐来对这些在结构体中重排列<br>m1  offset=0-3<br>m2    offset=4<br>offset=5-7不用，但是占领<br>m3    offset=8-11<br>union    offset=12-19<br>总共，占用5个内存块，一个20个字节。</p><p>例4：</p><pre class=" language-c"><code class="language-c">以下代码打印的结果是（假设运行在 <span class="token number">64</span> 位计算机上）：<span class="token keyword">struct</span> st_t <span class="token punctuation">{</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">short</span> <span class="token operator">*</span>pdata<span class="token punctuation">;</span>    <span class="token keyword">char</span> errstr<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>st_t st<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>esstr<span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>d”<span class="token punctuation">,</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//题目来自——牛客网</span></code></pre><p>//上面这道题，我们暂时不分析最后的结果，我们只分析在64位的机器下的这个结构体占用的字节。</p><table><tbody><tr><td bgcolor="#FFFF" ff=""><b>因为是64位环境下，所以默认对齐方式是8字节为一个内存块</b></td></tr></tbody></table><p><code>int status;</code>虽然int只占用4个 由于后面的指针八个字节放不下 填补不了空位 所以对其要八个字节(后面的4个为对齐位）<br><code>short *pdata;</code>这个指针会占用8个字节<br><code>char errstr[32];</code> 占用32个字节<br>所以一共占用 8+8+32=48个字节<br><code>char *p=(char *)(st[2].esstr+32)</code>，p实际指向了st[3]<br>则<code>p-(char *)(st))</code>，即为<code>&amp;st[3]-&amp;st[0]</code>,占用空间为3个结构体的大小，即3*48=14</p><p>例题5：（分析下面在32位编译环境的程序）</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">pragma</span> pack(2)</span><span class="token comment" spellcheck="true">//要是不加#pragma pack(2)，则是默认4字节对齐，我们其实可以看做#pragma pack(4)</span><span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c1<span class="token punctuation">;</span>    <span class="token keyword">char</span> c2<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>demo<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出为6   //因为加了#pragma pack(2)，根据规则2可以知道也是6</span></code></pre><p>例6：（可能嵌入式和网络编程中会用到这种用法：位段（也叫位域）一种特殊的类结构体语法）</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">struct</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> a<span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> c<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ab<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ab<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出4</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编译器底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 编译器底层 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言为什么没有数组下标越界检查？</title>
      <link href="/2020/06/07/2020_06_07_C_check_array_bounds/"/>
      <url>/2020/06/07/2020_06_07_C_check_array_bounds/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言为什么没有数组下标越界检查？"><a href="#C语言为什么没有数组下标越界检查？" class="headerlink" title="C语言为什么没有数组下标越界检查？"></a>C语言为什么没有数组下标越界检查？</h1><h2 id="一、综述"><a href="#一、综述" class="headerlink" title="一、综述"></a>一、综述</h2><p>我们常常在VS中看到这样的句子：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//提醒你说，strcpy是不安全的版本，建议使用安全版的strnpy</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>  _Dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>  _Source<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>  _Dest<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>  _Source<span class="token punctuation">,</span> size_t _Count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>原因：</p><blockquote><ul><li>C对数组的长度范围不会进行检查！当向数组越界写入数据的时候，经常产生“内存被破坏”的问题</li><li>直到，操作系统发现异常并且提示Segmentation fault，或者“强制关闭异常的应用程序”。但是此时相邻变量的值已经被破坏，程序却还在继续运行，那后果就不可想象了。</li></ul></blockquote><h2 id="二、C语言为什么不进行数组下标越界检查？"><a href="#二、C语言为什么不进行数组下标越界检查？" class="headerlink" title="二、C语言为什么不进行数组下标越界检查？"></a>二、C语言为什么不进行数组下标越界检查？</h2><p>补充背景：</p><blockquote><ul><li>我们知道对C来说，当数组名做函数参数时，它会被解读成指针。（退化为指针，一维数组退化为一级指针，二维数组退化为二级指针）</li><li>此外，我们可以利用指针的性质，控制好指针类型，即控制好<b>指针的步长</b>，我们就可以使用其他的指针变量指向数组的任意元素，并且这个指针可以随意进行加减运算。</li><li>比如我们在引用一维数组<code>int a[3];</code>我们在引用数组元素的时候，写成<code>a[i]</code>和<code>*(a+i)</code>，是等效的,因为在a被解读成指针的时候，他就指向该数组的第一个元素的地址。</li></ul></blockquote><p>原因：</p><blockquote><ul><li>1）当你向一个函数传递数组的时候，实际上你传递的是一个指向初始元素的指针。如果这个函数还存在于其他的代码文件中（<b>另外一个编译单元</b>），那么通过编译器是不可能追踪到数组的。所以，要求C语言在<b>编译时</b>生成检查数组长度的代码，是有些强人所难的意味的.<blockquote><ul><li>比如，你自己在开发一个模块，到时候要是extern进别人的一个数组，而那个模块的负责人还没把那个模块完成，那你又要测试，你到时候也不知道别人用你的模块是干什么的（比如，不知道到底他会传入一个多长的数组），那么你就只能写一个接口给他，说你传入一个地址的吧，到时候我在函数中判断。</li></ul></blockquote></li><li>2）为了提高运行效率，不检查数组下表越界，程序就可以跑得快，毕竟这样我就只需要传进一个地址，并不需要再传进一些额外的描述信息。<blockquote><ul><li>C的数组标识符，<b>里面并没有包含该数组长度的信息，只包含地址信息</b>，所以语言本身无法检查，只能通过编译器检查。</li><li>也因此，C语言才速度快，效率高。几乎所有对性能有苛刻要求的场合都使用C语言。</li></ul></blockquote></li><li>3）不检查下标还给程序员更大的空间，也为指针操作带来更多的方便。如果有这个检查的话指针的功能将会大大被削弱。</li></ul></blockquote><p>实际上，除了某些<b>解释型的编程语言</b>之外，目前几乎没有编译器可以为我们做数组的越界检查。</p><blockquote><ul><li>如果你在项目中需要检查边界这样的功能，你可以像下面这样模拟实现：<blockquote><ul><li>1）我们可以人工的像前面的安全版本的strnpy，进行额外的操作传进长度辅助就好了。</li><li>2）可以考虑将指针封装成结构体那样，运行时让指针自身持有可取值范围的信息。但是这样做对性能的影响很大，同时，也丧失了非调试模式下编译后的库和指针的兼容性。</li></ul></blockquote></li></ul></blockquote><h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><p>标准C语言是不进行数组下表越界检查的。<br>但目前各种编译器对这些行为的处理不同，<br>使得这样的行为是未定义的，建议不要写这样的代码：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下标越界</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//DevC++5.11编译通过，而且还输出了1</span><span class="token comment" spellcheck="true">//VS2012则表示，下标越界，会报错。缓冲区“a”(大小为 24 字节)将溢出</span></code></pre><blockquote><ul><li>访问数组的本质是访问一段连续内存中的某个单元，只要这个单元的内存是可用的，那么程序就暂时不会崩溃，但是不立即崩溃，并不是是就完事大吉了，有时候可能真的没太大影响，但是有时候会修改到你正好要用到的数据。（所以，这种内存单元可用的，我们也不要这写，特别是在<b>多线程编程</b>的时候）</li><li>更严重的，有时候数组越界正好越界到了操作系统的内存保护区域，会导致内存不可用的原因，由于操作系统的内存保护机制，程序会因此而崩溃。</li></ul></blockquote><h2 id="四、防范"><a href="#四、防范" class="headerlink" title="四、防范"></a>四、防范</h2><p>为了防范这样的可能被用于缓冲区溢出攻击的语法，建议使用更加安全版本的函数。<br>比如，strcpy改用strnpy</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言标准的发展进程</title>
      <link href="/2020/06/06/2020-06-06-The-development-of-C-language-standard/"/>
      <url>/2020/06/06/2020-06-06-The-development-of-C-language-standard/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言标准的发展进程"><a href="#C语言标准的发展进程" class="headerlink" title="C语言标准的发展进程"></a>C语言标准的发展进程</h1><h2 id="一、综述"><a href="#一、综述" class="headerlink" title="一、综述"></a>一、综述</h2><p>本文将讲解C语言各种标准，并且描述其特点。<br>用处：帮助在开发中了解编译器支持什么标准，<b>更好的分析可能的编译出错原因</b>，因为，有时候可能因为当前编译器支持的标准不同就会导致编译出错。</p><h2 id="二、各种标准细说"><a href="#二、各种标准细说" class="headerlink" title="二、各种标准细说"></a>二、各种标准细说</h2><h3 id="1）标准——K-amp-R-C"><a href="#1）标准——K-amp-R-C" class="headerlink" title="1）标准——K&amp;R C"></a>1）标准——K&amp;R C</h3><blockquote><ul><li>1978年，丹尼斯•里奇（Dennis Ritchie）和布莱恩•柯林汉（Brian Kernighan）合作出版了<b>《C程序设计语言》的第一版</b>。<b>书中介绍的C语言标准也被称作“K&amp;R C”</b>。</li></ul></blockquote><h3 id="2）标准——ANSI-C、ISO-C、C89、C90-（重点）"><a href="#2）标准——ANSI-C、ISO-C、C89、C90-（重点）" class="headerlink" title="2）标准——ANSI C、ISO C、C89、C90  （重点）"></a>2）标准——ANSI C、ISO C、C89、C90  <font color="red" size="5">（重点）</font></h3><p><font color="red" size="4">(目前，我们说的<b>标准C</b>指的一般就是ANSI C)</font><br>典型用书:《C程序设计语言》的<font color="red" size="4"><b>第二版</b></font></p><img src="/photos/2020.6.03_15/2020_06_06_1.jpg" width="60%"><blockquote><ul><li>随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。1983年，<b>美国国家标准协会（ANSI）</b>组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于<b>1989年</b>完成，这个版本的语言经常被称作<b>ANSI C</b>，或有时称为<b>C89（为了区别C99）</b>。</li><li>在<b>1990年</b>，ANSI C标准（带有<b>一些小改动</b>）被美国国家标准协会（ANSI）采纳为ISO/IEC 9899:1990。这个版本有时候称为<b>C90</b>或者<b>ISO C</b>。</li><li>综上，通常情况下，我们不加非常严格的区分，ANSI C、ISO C、C89、C90可以看做是同一种标准。</li></ul></blockquote><p>传统C语言（K&amp;R C）到 ANSI/ISO标准C语言的<b>改进</b>包括：</p><blockquote><ul><li>增加了真正的标准库  </li><li>新的预处理命令与特性  </li><li>函数原型允许在函数申明中指定参数类型  </li><li>一些新的关键字，包括 const、volatile 与 signed  宽字符、宽字符串与字节多字符  </li><li>对约定规则、声明和类型检查的许多小改动与澄清</li></ul></blockquote><h3 id="三、标准——C99"><a href="#三、标准——C99" class="headerlink" title="三、标准——C99"></a>三、标准——C99</h3><blockquote><ul><li>2000年3月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。</li><li>C99新增了一些特性:<blockquote><ul><li>1)<b>支持不定长的数组（柔性数组）</b>，即数组长度可以在运行时决定。  </li><li>2)变量声明不必放在语句块的开头，for 语句<b>提倡写成 for(int i=0;i&lt;100;++i) 的形式</b>，即i 只在for 语句块内部有效</li><li>3)初始化结构的时候允许对特定的元素赋值。  </li><li>4)允许编译器化简非常数的表达式。</li><li>5)<b>取消了函数返回类型默认为 int 的规定。</b></li><li>Tips：但是各个公司对C99的支持所表现出来的兴趣不同。当GCC和其它一些商业编译器支持C99的大部分特性的时候，微软和Borland却似乎对此不感兴趣，他们把更多的精力放在了C++上。</li></ul></blockquote></li></ul></blockquote><p>典型的会造成下面情况的发生：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// C99允许在for循环内定义循环变量，而ANSIC C（C89）不允许</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的语句，在ANSI C，是不能通过编译的。因为他不支付，编译后会显示：<br>[Error] ‘for’ loop initial declarations are only allowed in C99 or C11 mode<br>但是，从C99开始，就可以编译通过了。<br>gcc下用这个方式可以指定用C99标准编译：</p><pre class=" language-bash"><code class="language-bash">gcc -std<span class="token operator">=</span>c99 test.c -o test.exe</code></pre><p>Tips：</p><blockquote><ul><li>1)另外，事实上，<b>不定长数组</b>的定义早在C的C99标准里就已经被提出，但是<b>从来都没在C++标准（C++98、C++03、C++11）里存在过</b>。因此，<b>G++支持不定长数组完全是因为它<font color="red" size="4">同时支持C99和C++</font>（对C99标准支持得最好的就是G++了）</b>，而VS不怎么支持C99标准那是人尽皆知的，也就理所当然不支持C99的不定长数组了。</li><li>2)此外，目前没有编译器可以完全实现C99，而且<b>为了兼容性，在写C代码时，通常我们不会去用C99标准</b>，<b>编译器也是默认不使用C99</b>的，因此C语言的书里说不允许这样定义数组，也是可以理解的。而C++ primer里也这么说，那是因为它说的是事实，C++里根本就不支持不定长数组。</li><li>3)大概也是因为如上的原因，所以，<font color="red" size="3">到目前为止，我们还是认为ANSI C才是标准C</font>。</li></ul></blockquote><h3 id="四、标准——C11"><a href="#四、标准——C11" class="headerlink" title="四、标准——C11"></a>四、标准——C11</h3><blockquote><ul><li>在2011年12月，ANSI 采纳了 ISO/IEC 9899:2011 标准。这个标准通常即C11，它是C程序语言的最新标准。</li><li>与C99相比，C11有这些变化：<blockquote><ul><li>1）对齐处理：alignof(T)返回T的对齐方式，aligned_alloc()以指定字节和对齐方式分配内存，头文件&lt;stdalign.h&gt;定义了这些内容。</li><li>2）<em>Noreturn：<em>Noreturn是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于gcc的__attribute</em></em>((noreturn))，后者在声明语句尾部。</li><li>3）_Generic：_Generic支持轻量级范型编程，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。</li><li>4）_Static_assert()：_Static_assert()，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的assert()在运行时刻断言。</li><li>5）安全版本的几个函数：gets_s()取代了gets()，原因是后者这个I/O函数的实际缓冲区大小不确定，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。</li><li>6）fopen()新模式：fopen()增加了新的创建、打开模式“x”，在文件锁中比较常用。</li><li>7）匿名结构体、联合体。</li><li>8）多线程：头文件&lt;threads.h&gt;定义了创建和管理线程的函数，新的存储类修饰符_Thread_local限定了变量不能在多线程之间共享。</li><li>9）_Atomic类型修饰符和头文件&lt;stdatomic.h&gt;。</li><li>10）改进的Unicode支持和头文件&lt;uchar.h&gt;。</li><li>11）quick_exit()：又一种终止程序的方式，当exit()失败时用以终止程序。</li><li>12）复数宏，浮点数宏。</li><li>13）time.h新增timespec结构体，时间单位为纳秒，原来的timeval结构体时间单位为毫秒。     </li></ul></blockquote></li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sscanf使用</title>
      <link href="/2020/06/05/2020-06-05-sscanf/"/>
      <url>/2020/06/05/2020-06-05-sscanf/</url>
      
        <content type="html"><![CDATA[<h1 id="详解sscanf"><a href="#详解sscanf" class="headerlink" title="详解sscanf"></a>详解sscanf</h1><h2 id="一、综述"><a href="#一、综述" class="headerlink" title="一、综述"></a>一、综述</h2><blockquote><ul><li>正则表达式Regex(regular expression)是一种强大的描述字符序列的工具。在许多语言中都存在着正则表达式.</li></ul></blockquote><p>sscanf可以用来实现一些简易的类正则表达式功能，提高对字符串的处理效率，但却没有正则表达式强大,所以如果对于比较复杂的字符串处理,建议使用正则表达式。<br>注：C语言中sscanf实现的只是的<b>类正则表达式功能</b>，并不是真的支持正则表达式</p><blockquote><ul><li>C++语言中，也只有C++11的时候，才将正则表达式纳入了新标准的一部分</li><li>不仅如此，它还支持了6种不同的正则表达式的语法，分别是：ECMASCRIPT、basic、extended、awk、grep和egrep。其中ECMASCRIPT是默认的语法，具体使用哪种语法我们可以在构造正则表达式的时候指定。（本段文字还未考证）</li><li>C++11中使用正则表达式，需要include头文件<b>（regex.h）</b></li><li>在DevC++中编译器默认没有开C++11标准的编译，所以显示没有这个头文件。（但你可以在DevC++中自行启用编译选项，加入<b>（-std=c++11）</b>用C++11就有了）</li></ul></blockquote><h2 id="二、sscanf的用法"><a href="#二、sscanf的用法" class="headerlink" title="二、sscanf的用法"></a>二、sscanf的用法</h2><h3 id="1、跳过数据"><a href="#1、跳过数据" class="headerlink" title="1、跳过数据"></a>1、跳过数据</h3><blockquote><ul><li>语法：<blockquote><ul><li><b>跳过的话，就是加一个*</b>，然后就可以跳过*后面的那种</li><li>比如，%*s或%*d    </li></ul></blockquote></li></ul></blockquote><pre class=" language-c"><code class="language-c">例<span class="token punctuation">:</span> <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"1234 5678"</span><span class="token punctuation">,</span> <span class="token string">"%*d %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里的d和后面的%之间有个空格</span><span class="token comment" spellcheck="true">//%d的话就是要一个整数，而&lt;b>%*d就是将整数跳过&lt;/b></span></code></pre><p>例子：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"1234 5678"</span><span class="token punctuation">,</span><span class="token string">"%*d %s"</span><span class="token punctuation">,</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//跳过1234，然后隔一个空格再获取字符串</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出为：</span><span class="token comment" spellcheck="true">//5678</span></code></pre><h3 id="2、读指定宽度的数据"><a href="#2、读指定宽度的数据" class="headerlink" title="2、读指定宽度的数据"></a>2、读指定宽度的数据</h3><blockquote><ul><li>语法：<blockquote><ul><li>比如，<b>%[width]s</b> ，<b>%[width]d</b>  其中，[]表示的是<b>可选</b>（也就是可以省略的意思）</li><li>例: sscanf(“12345678”, “%4s”, buf);</li></ul></blockquote></li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例1 :</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"12345678"</span><span class="token punctuation">,</span><span class="token string">"%4s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从字符串中获取字符串，只要4个字节，存放在buf中</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//1234</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例2 :</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"12345678"</span><span class="token punctuation">,</span><span class="token string">"%3d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出的：</span><span class="token comment" spellcheck="true">//123</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例3 :(综合1和2)</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"12345678"</span><span class="token punctuation">,</span><span class="token string">"%*3d%3d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//456</span></code></pre><h3 id="3、支持集合操作"><a href="#3、支持集合操作" class="headerlink" title="3、支持集合操作"></a>3、支持集合操作</h3><table><tbody><tr><td bgcolor="#FFFF" ff="">注意：只支持获取到字符串中去，不能获取到整数中去！！！</td></tr></tbody></table><blockquote><ul><li>语法：<blockquote><ul><li>%[a-z]表示匹配a到z中任意字符(具有贪婪性——尽可能多的匹配)</li><li>%[^a-z]表示读取除a-z<b>以外</b>的所有字符,其实，你可以a-z也可以b-f，他是一个ASCII码范围。</li><li>%[aBc]匹配a、B、c中这几个列出了的字符中的，贪婪性</li><li>%[^aFc]匹配<b>非</b>aFc的任意字符，贪婪性</li></ul></blockquote></li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例1：</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>    <span class="token function">sscanf</span> <span class="token punctuation">(</span><span class="token string">"agkd32DajfDdFF"</span><span class="token punctuation">,</span> <span class="token string">"%[a-z]"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从字符串中获取输入只要'a''g''k''d'</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为agkd</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例2：(综合1和3)</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>    <span class="token function">sscanf</span> <span class="token punctuation">(</span><span class="token string">"agkd32DajfDdFF"</span><span class="token punctuation">,</span> <span class="token string">"%*[a-z]%[^a-z]"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//先跳过，然后要ASCII码不是a-z区间的字符     </span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为32D</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例3：(综合2和3)</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>    <span class="token function">sscanf</span> <span class="token punctuation">(</span><span class="token string">"agkd32DajfDdFF"</span><span class="token punctuation">,</span><span class="token string">"%*[a-z]%5s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//先跳过，然后扫描进5个字节的字符</span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为32Daj </span></code></pre><p><font color="red" size="4">本样例，需注意</font></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例4：</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一旦碰到我不要的，后面的也不看</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"ASHJ$12agkd32DajfDdFF"</span><span class="token punctuation">,</span><span class="token string">"%[^a-z]"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为ASHJ$12</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//例5：</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"acsfsacssss"</span><span class="token punctuation">,</span><span class="token string">"%[absc]"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为acs</span></code></pre><p><font color="red" size="4">易错样例：</font></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>    <span class="token function">sscanf</span> <span class="token punctuation">(</span><span class="token string">"32DajfDdFF"</span><span class="token punctuation">,</span> <span class="token string">"%[1-9]"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先跳过，然后要ASCII码不是a-z区间的     </span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输入32</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>     <span class="token function">sscanf</span> <span class="token punctuation">(</span><span class="token string">"32DajfDdFF"</span><span class="token punctuation">,</span> <span class="token string">"%[1-9]"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先跳过，然后要ASCII码不是a-z区间的     </span>    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 出错，不支持，扫描到数字中去！！！</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三、sscanf的实际应用"><a href="#三、sscanf的实际应用" class="headerlink" title="三、sscanf的实际应用"></a>三、sscanf的实际应用</h2><blockquote><ul><li>解析网络的数据包<blockquote><ul><li>验证E-mail格式</li><li>验证IP地址</li><li>验证URL</li><li>验证电话号码,邮政编号，各种。</li></ul></blockquote></li></ul></blockquote><h2 id="四、借此来深刻理解，为什么以前我们要记忆那么多所谓的格式字符了"><a href="#四、借此来深刻理解，为什么以前我们要记忆那么多所谓的格式字符了" class="headerlink" title="四、借此来深刻理解，为什么以前我们要记忆那么多所谓的格式字符了"></a>四、借此来深刻理解，为什么以前我们要记忆那么多所谓的格式字符了</h2><p>sscanf和scanf和printf的联系</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"AAA123BBB456"</span><span class="token punctuation">,</span><span class="token string">"%*[^0-9]%i"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//先跳过，然后扫描整数  </span>    <span class="token comment" spellcheck="true">//其实上面一句等价于，sscanf("AAA123BBB456","%*[^0-9]%d",&amp;num); </span>    <span class="token comment" spellcheck="true">//也就是%d和%i都是十进制整数的格式字符，我之所以在这用的是%i</span>    <span class="token comment" spellcheck="true">//是为了将正则表达式中类似的语法导入进来，i（integer整数） </span>    <span class="token comment" spellcheck="true">//此外，我们可以发现，其实我们在scanf扫入和printf输出的时候，也都用了格式字符 </span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为123</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token string">"AAA123BBB456"</span><span class="token punctuation">,</span><span class="token string">"%*[^0-9]%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为1</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//补充例子</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span>  <span class="token operator">*</span>line<span class="token operator">=</span><span class="token string">"6161665058"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">sscanf</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span><span class="token string">"%2[{0|1|6}]"</span><span class="token punctuation">,</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果为61</span></code></pre><p>（此处还需补充更好的例子）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解C++中const常见用途</title>
      <link href="/2020/06/04/2020-06-04-Const-in-C-language/"/>
      <url>/2020/06/04/2020-06-04-Const-in-C-language/</url>
      
        <content type="html"><![CDATA[<h1 id="详解C-中const常见用途"><a href="#详解C-中const常见用途" class="headerlink" title="详解C++中const常见用途"></a>详解C++中const常见用途</h1><p>C++对C语言的const关键字进行了增强！<br><font color="red" size="3"><br>特点：<br>C++中的const修饰的变量，变成了真正的常量，所以叫const常量</font></p><blockquote><ul><li>区别：<blockquote><ul><li>1）C语言中的const变量<br>C语言中const变量是只读变量，<b>有自己的存储空间</b></li><li>2）C++中的const常量<br>注意：<b>可能分配存储空间,也可能不分配存储空间!</b></li></ul></blockquote></li></ul></blockquote><p>Tips:要想了解C++中const实现机制，请移步《C++中对C的const关键字增强》一文</p><h2 id="1）const成员函数"><a href="#1）const成员函数" class="headerlink" title="1）const成员函数"></a>1）const成员函数</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> itslength<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//成员函数声明为常量</span></code></pre><p>当成员函数被声明为const时，如果这个const成员函数试图修改这个对象的数据，编译器将视为错误。<br>因为：你都和我约定了不能修改，那就得履行。</p><h2 id="2）指向const对象的指针"><a href="#2）指向const对象的指针" class="headerlink" title="2）指向const对象的指针"></a>2）指向const对象的指针</h2><p>如果声明了一个<b>指向const对象</b>的指针，则通过该指针只能调用const方法（成员函数）。</p><blockquote><p>-因为：const就是用来规定，<b>属于这个对象</b>的是不能有改变的</p><blockquote><ul><li>const成员函数（常量成员函数），不会去修改这个对象任何<b>非静态成员变量</b>的值。</li><li>static成员函数（静态成员函数），也不会去修改这个对象任何<b>非静态成员变量</b>(毕竟，静态成员函数和静态成员变量其实本质是全局变量嘛，不需要作用在具体的对象上，<b>我们写在类里面，只是为了彰显和这个类有紧密的关系</b>)</li><li>因此，我们指向const对象的指针，能够调用的是const成员函数和static成员函数</li><li>普通成员函数，内部可以实现修改非静态成员变量的语句，所以<b>可能会破坏const对象规定的，不能改变我的内部数据的原则</b>。</li></ul></blockquote></blockquote><pre class=" language-cpp"><code class="language-cpp">Rectangle<span class="token operator">*</span> pRect <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span><span class="token keyword">const</span> Rectangle <span class="token operator">*</span> pConstRect <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//指向const对象</span>Rectangle<span class="token operator">*</span> <span class="token keyword">const</span> pConstPtr <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。</span></code></pre><h2 id="3）const-修饰函数的返回值"><a href="#3）const-修饰函数的返回值" class="headerlink" title="3）const 修饰函数的返回值"></a>3）const 修饰函数的返回值</h2><p>函数返回值采用“引用传递”的场合,出现在类的赋值函数中，目的是为了实现链式表达。<br>例如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>A <span class="token operator">&amp;</span> operate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 赋值函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span>A a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a, b, c 为A 的对象</span>a <span class="token operator">=</span> b <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正常的链式赋值</span><span class="token punctuation">(</span>a <span class="token operator">=</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不正常的链式赋值，但合法</span><span class="token comment" spellcheck="true">//如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</span></code></pre><h2 id="4）补充"><a href="#4）补充" class="headerlink" title="4）补充"></a>4）补充</h2><blockquote><ul><li>非const对象可以访问<b>任意的</b>成员函数,自然包括const成员函数,静态成员函数</li><li>const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.</li><li>const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查。</li><li>然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</li></ul></blockquote><p>补充杂项：</p><blockquote><ul><li>const 修饰引用（&amp;）修饰输入参数的用法：<blockquote><ul><li>1-对于<b>非内部数据类型</b>的输入参数，应该将“<b>值传递</b>”的方式改为“<b>const 引用传递</b>”，目的是提高效率。例如将<code>void Func(A a)</code> 改为<code>void Func(const A &amp;a)</code>。当然，虽然这样的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</li><li>2-对于<b>内部数据类型</b>的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如<code>void Func(int x)</code> 不应该改为<code>void Func(const int &amp;x)</code>。（如何理解？？？）</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>const 修饰星号（*）用法：<blockquote><ul><li>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数</li></ul></blockquote></li></ul></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>如下语句将出现编译错误：<span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>正确的用法是<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解C语言中const</title>
      <link href="/2020/06/03/2020-06-03-Const-in-C-language/"/>
      <url>/2020/06/03/2020-06-03-Const-in-C-language/</url>
      
        <content type="html"><![CDATA[<h1 id="详解C语言中const"><a href="#详解C语言中const" class="headerlink" title="详解C语言中const"></a>详解C语言中const</h1><p><font color="red" size="4">C语言中的const修饰的变量，叫做<b>常变量</b>（奇怪的名字）</font></p><h2 id="1）概述："><a href="#1）概述：" class="headerlink" title="1）概述："></a>1）概述：</h2><p>Q：C语言中，const关键字限定一个变量为只读，但它是真正意义上的只读吗？<br>A：C语言中的并不是的！const虽说是constant的简写，是不变的意思。<br>但在C语言中，const并不是说它修饰常量，而是说它限定一个变量为只读。</p><blockquote><ul><li><b>C语言</b>中，const关键字修饰的变量并<b>非真正意义完完全全的只读</b>！</li><li>（难怪叫<b>常变量</b>,<font color="blue">因为C语言中const就没有把这个变量变成常量！）</font></li></ul></blockquote><p>Tips：<b>C++</b>中则对const关键字进行了加强，使得真的变成了常量（详情见C++中const详解）<br>所以，<b>我们常说C++中const修饰的变量，叫做const常量。</b></p><h2 id="2）基本用法："><a href="#2）基本用法：" class="headerlink" title="2）基本用法："></a>2）基本用法：</h2><h3 id="1—修饰普通变量"><a href="#1—修饰普通变量" class="headerlink" title="1—修饰普通变量"></a>1—修饰普通变量</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//与int const num等价</span>num <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//编译错误，不可再次修改</span></code></pre><p>DevC++的C语言编译器编译：<br>[Error] assignment of read-only variable ‘NUM’<br>解释：<br>由于使用了const修饰NUM，使得NUM为只读，因此尝试对NUM再次赋值的操作是非法的，编译器将会报错。所以，如果需要使用const修饰一个变量，那么它只能在开始声明时就赋值，否则用<b>一般做法</b>在后面就没有机会了（比如，特别的，C语言中可以用指针间接改变）。</p><h3 id="2—修饰数组"><a href="#2—修饰数组" class="headerlink" title="2—修饰数组"></a>2—修饰数组</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//使用const关键字修饰数组，使其元素不允许被改变</span><span class="token comment" spellcheck="true">//试图修改arr的内容的操作是非法的，编译器将会报错</span><span class="token keyword">const</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//与int const arr[]等价</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//编译错误</span></code></pre><p>DevC++的C语言编译：<br>[Error] assignment of read-only location ‘arr[2]’</p><h3 id="3—修饰指针（重点）"><a href="#3—修饰指针（重点）" class="headerlink" title="3—修饰指针（重点）"></a>3—修饰指针（重点）</h3><p>先补充</p><blockquote><ul><li>下面这两种写法是等效的的！<blockquote><ul><li>const int a=3;</li><li>int const a=3;</li></ul></blockquote></li></ul></blockquote><p>修饰指针的主要有以下几种情况：<br>1）const 修饰 *p，<b>指向的对象只读</b>，指针的指向可变:</p><blockquote><ul><li>常量指针——指向常量的指针，顾名思义，就是指针指向的是常量，即它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而指向另一个常量。</li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p是一个指向int类型的const值,与int const *p等价</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译错误，指向的对象是只读的，不可通过p进行改变</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//合法，改变了p的指向</span></code></pre><p>换句话说更加准确：指针P是指向const int *</p><p>这里为了便于理解，可认为const修饰的是<em>p，通常使用</em>对指针进行解引用来访问对象，因而该对象是只读的。</p><p><font color="red" size="5">（此处补充——《C专家编程》书中的一段）</font></p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>Ccp<span class="token punctuation">;</span>ccp <span class="token operator">=</span> Cp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左操作数是一个指向有const限定符的char的指针。</span><span class="token comment" spellcheck="true">//右操作数是一个指向没有限定符的char的指针。</span><span class="token comment" spellcheck="true">//char类型与char类型是相容的，左操作数所指向的类型具有右操作数所指向类型的限定符(无)，再加上自身的限定符(const)。</span><span class="token comment" spellcheck="true">//注意，反过来就不能进行赋值。试试下而的代码:</span>cp <span class="token operator">=</span> ccp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*结果产生编译警告*/</span></code></pre><p>解释：</p><blockquote><ul><li>const char *ccp;//表示我保证，我不会去改变我指向的那个对象</li><li>char *cp;//表示我可以改变我指向的那个对象</li><li>我们可以，想想一下一个场景来理解ccp和cp的相互赋值的合法性<blockquote><ul><li>ccp=cp;//表示，cp告诉ccp说，我给你的对象，我可以改变，我赋值给你，你要是想改也可以。ccp说,我是有原则的，我的原则就是，我不会去改变我指向的那个对象（相容），ccp说，行，随你。</li><li>cp=ccp;//表示，ccp告诉cp，我给你的对象，我可舍不得改了，我赋值给你，你可不能改，ccp说，我也是有原则的，我就要改，而它一改，编译器就阻止它说，你这样不行，侵犯了ccp的原则。</li></ul></blockquote></li></ul></blockquote><p>2) const修饰p，指向的对象可变，<b>指针的指向不可变</b>：</p><blockquote><ul><li>指针常量——指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。它指向的地址将伴其一生，直到生命周期结束。有一点需要注意的是，指针常量在定义时必须同时赋初值。</li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p是一个const指针</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//合法，</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//编译错误，p是一个const指针，只读，不可变</span></code></pre><p>3) 指针不可改变指向，指向的内容也不可变</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p既是一个const指针，同时也指向了int类型的const值</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//编译错误，指向的对象是只读的，不可通过p进行改变</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//编译错误，p是一个const指针，只读，不可变</span></code></pre><p>小结：<br>const放在<em>的左侧，限定了该指针指向的对象是只读的；<br>const放在</em>的右侧，限定了指针本身是只读的，即不可变的。</p><table><tbody><tr><td bgcolor="#FFFF">记忆法：const右边修饰谁，就说明谁是不可变的</td></tr></tbody></table><p>解释：</p><blockquote><ul><li>首先我们去掉类型说明符，查看const右边修饰的内容，上面三种情况去掉类型说明符int之后，如下：</li><li>const <em>p; //修饰</em>p，指针指向的对象不可变</li><li>* const p; //修饰p，指针不可变</li><li>const * const p; //第一个修饰了*p，第二个修饰了p，两者都不可变</li><li>此外，这种记忆法，还能帮助记忆先前那两个等价的形式：<blockquote><ul><li>const int NUM = 10;     //与int const NUM等价</li><li>const int *p  = &amp;a;        //与int const *p等价</li><li>const int arr[] = {0,0,2,3,4};     //与int const arr[]等价</li></ul></blockquote></li></ul></blockquote><h3 id="3—修饰函数形参（重点，在函数接口，控制指针只做输入-in-）"><a href="#3—修饰函数形参（重点，在函数接口，控制指针只做输入-in-）" class="headerlink" title="3—修饰函数形参（重点，在函数接口，控制指针只做输入/in/）"></a>3—修饰函数形参（重点，在函数接口，控制指针只做输入/<em>in</em>/）</h3><p>实际上，为我们可以经常发现const关键字的身影，例如很多库函数的声明：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字符串拷贝函数</span><span class="token keyword">int</span>  <span class="token operator">*</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字符串比较函数</span></code></pre><p>观察一个例子：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//test.c</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">myPrint</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myPrint</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>    str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my print:%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    <span class="token function">myPrint</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>此例子中，我们不希望myPrint函数修改传入的字符串内容，因此入参使用了const限定符，表明传入的字符串是只读的，因此，如果myPrint函数内部如果尝试对str进行修改，将会报错:<br>error: assignment of read-only location ‘*str’str[0] = ‘H’;</p><p><b>工程常用做法</b>：</p><blockquote><ul><li>我们在编码过程中，如果确定传入的指针参数仅用于访问数据，那么应该将其声明为一个指向const限定类型的指针，避免函数内部对数据进行意外地修改!!!</li></ul></blockquote><h3 id="4-修饰全局变量"><a href="#4-修饰全局变量" class="headerlink" title="4-修饰全局变量"></a>4-修饰全局变量</h3><p>我们知道，使用全局变量是一种不安全的做法，因为程序的任何部分都能够对全局数据进行修改。而如果对全局变量增加const限定符（假设该全局数据不希望被修改），就可以避免被程序其他部分修改。这里有两种使用方式。<br>1）第一种，在a文件中定义，其他文件中使用外部声明，例如：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//a.h</span><span class="token keyword">const</span> <span class="token keyword">int</span> ARR<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义int数组</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//b.c</span><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ARR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//注意，这里不能再对ARR进行赋值</span><span class="token comment" spellcheck="true">//后面可以使用ARR</span></code></pre><p>2）第二种，在a文件中定义，并使用static修饰，b文件包含a文件，例如：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//a.h</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> ARR<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义int数组</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//b.c</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;a.h></span></span><span class="token comment" spellcheck="true">//后面可以使用ARR</span>注意，这里必须使用<span class="token keyword">static</span>修饰，否则多个文件包含导致编译会出现重复定义的错误。可以尝试一下。（为什么？因为，<span class="token keyword">static</span>修饰的变量，要是初始化了是放在<span class="token punctuation">.</span>data段的，而不是栈区）</code></pre><table><tbody><tr><td bgcolor="#FFFF" ff="">易错点：Q：C语言中const修饰的变量是真正的只读吗？A：C语言const修饰的变量，可以被间接修改！</td></tr></tbody></table><p>在C语言中，const变量只不过是修饰该变量名，它并不能使内存变为只读。也就是说，我们不能通过变量名再去操作这块内存。但是可以通过其它方法，如指针，通过指针是可以修改被const修饰的那块内存的。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2018</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2019</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>DevC++虽然有一个警告：<br> [Warning] initialization discards ‘const’ qualifier from pointer target type<br>（[警告]初始化会从指针目标类型中丢弃’const’限定符）<br>但是还是可以修改！！！<br>可以看到，我们通过另外定义一个指针变量，将被const修饰的a的值改变了。<br>此外，对于由于像数组溢出，隐式修改等程序不规范书写造成的运行过程中的修改，编译器是无能为力的，也说明const修饰的变量仍然是具备变量属性的。</p><p>我们要知道的是，const关键字告诉了编译器，它修饰的变量不能被改变，如果代码中发现有类似改变该变量的操作，那么编译器就会捕捉这个错误。</p><p>那么它在<b>实际中的意义之一</b>是什么呢？<br>帮助程序员提前发现问题，避免不该修改的值被意外地修改，但是无法完全保证不被修改！<br>也就是说，C语言中<b>const关键字是给编译器用的</b>帮助程序员提早发现可能存在的问题。<br>（所以给了个warning？但是却不给error，也是够了。）</p><p>从这次的分析中，我们可以获得的思考：<br>1）<b>不要忽略编译器的警告，除非你很清楚在做什么</b>。（比如，上面我们用那些方法修改了const修饰的。）<br>2）虽然可以通过某种不正规途径修改const修饰的变量，但是在<b>工程中</b>永远不要这么做。<br>3）const关键字让编译器帮助我们发现变量不该被修改却被意外修改的错误。</p><p><font color="red" size="5">常见的问题：</font><br>C语言中:</p><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> test<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//[Error] variably modified 'aa' at file scope</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">1000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> test<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译出错，[Error] variably modified 'test' at file scope</span><span class="token comment" spellcheck="true">//在文件范围内可变地修改了“test”，因为数组的下标只接受常量，而C语言中const修饰的变量是个“假的常量”</span><span class="token comment" spellcheck="true">//当然，上面语法在Ｃ＋＋中是可以的，因为C++对C语言中const关键字进行了加强，使得真的是常量了，</span><span class="token comment" spellcheck="true">//而且，在C++中，还给const修饰而形成的常量，取名叫做const常量。</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的初始化</title>
      <link href="/2020/06/02/2020-06-02-C-Array-init/"/>
      <url>/2020/06/02/2020-06-02-C-Array-init/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的不完全初始化"><a href="#数组的不完全初始化" class="headerlink" title="数组的不完全初始化"></a>数组的不完全初始化</h1><h2 id="一、问题由来"><a href="#一、问题由来" class="headerlink" title="一、问题由来"></a>一、问题由来</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> 把数组全部初始化为<span class="token number">0</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span> 把数组全部初始化为<span class="token number">1</span>，为什么却失败了呢？</code></pre><h2 id="二、数组的几种初始化方式"><a href="#二、数组的几种初始化方式" class="headerlink" title="二、数组的几种初始化方式"></a>二、数组的几种初始化方式</h2><h3 id="1）完全初始化（-completely-initialized-）给每个元素初始化"><a href="#1）完全初始化（-completely-initialized-）给每个元素初始化" class="headerlink" title="1）完全初始化（$completely initialized$）给每个元素初始化"></a>1）完全初始化（$completely initialized$）给每个元素初始化</h3><p>int a[5]={0,1,2,3,4};<br>int a[]={1,2,3};</p><h3 id="2）完全不初始化（-uninitialized-）"><a href="#2）完全不初始化（-uninitialized-）" class="headerlink" title="2）完全不初始化（$uninitialized$）"></a>2）完全不初始化（$uninitialized$）</h3><p>int a[5];<br>注意：<br>不进行显式初始化的情况下：</p><blockquote><ul><li><b>未初始化的</b>全局变量以及静态变量的初始均为0（因为他们都存在.bss段，默认初始化为0）</li><li><b>未初始化的</b>局部变量（自动变量）随机（其实也不叫随机，要是你能够精确的设计上一个释放这块内存的地方存了什么值，你就能自行控制，局部变量处于栈区，其数值是当时内存中的值。）</li></ul></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:(不确定的)</span><span class="token comment" spellcheck="true">//6487736</span><span class="token comment" spellcheck="true">//4202350</span><span class="token comment" spellcheck="true">//4202256</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//29</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><h3 id="3）不完全初始化（-partly-initialized-）（即：部分初始化）"><a href="#3）不完全初始化（-partly-initialized-）（即：部分初始化）" class="headerlink" title="3）不完全初始化（$partly initialized$）（即：部分初始化）"></a>3）不完全初始化（$partly initialized$）（即：部分初始化）</h3><p>int a[5]={0,1,2};<br>K&amp;R C语言中是这样阐述：</p><blockquote><ul><li><b>如果初始化表达式的个数比数组元素数少，则对外部变量，静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0。</b>（至于为什么是初始化为0而不是其他的，原因是.bss的实现机制）</li><li>如果初始化表达式的个数比数组元素数多,则是错误的。<br>所以，上面数组，前三个元素被初始化为0，1，2，后两个元素被初始化为0。</li></ul></blockquote><p>实际上，int a[5]={0};属于不完全初始化，先把第一个元素初始化为0，由于初始化元素个数不够，所以剩余的元素按照规则被初始化为0，虽然都是0，但是它和后面那些0的意义不同（此0非彼0）</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//1</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//1</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><h3 id="4）假装初始化（我编的。。）"><a href="#4）假装初始化（我编的。。）" class="headerlink" title="4）假装初始化（我编的。。）"></a>4）假装初始化（我编的。。）</h3><p><code>int a[10]={};</code><br>编译器自动将<strong>所有元素置0</strong></p><h2 id="三、初始化和赋值区别："><a href="#三、初始化和赋值区别：" class="headerlink" title="三、初始化和赋值区别："></a>三、初始化和赋值区别：</h2><p>只有在数组定义时，给数组值才叫初始化<br>定义过后，再给数组值叫赋值</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配之BF&amp;RK</title>
      <link href="/2020/06/01/2020-06-01-BF-RK/"/>
      <url>/2020/06/01/2020-06-01-BF-RK/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串匹配算法预告"><a href="#字符串匹配算法预告" class="headerlink" title="字符串匹配算法预告"></a><font face="楷体">字符串匹配算法预告</font></h1><blockquote><ul><li><font face="楷体" color="red" size="5">单模式串匹配算法</font><blockquote><ul><li><b>BF算法</b>（Brute Force 的缩写，也叫暴力匹配算法，朴素匹配算法)<blockquote><ul><li>Brute adj. 蛮干不动脑筋的</li></ul></blockquote></li><li><b>RK算法</b>（Rabin-Karp 算法）<blockquote><ul><li>由它的两位发明者 Rabin 和 Karp 的名字来命名的</li></ul></blockquote></li><li><b>BM算法</b>（Boyer-Moore 算法）<blockquote><ul><li>它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的KMP 算法的3到4倍。</li></ul></blockquote></li><li><b>KMP算法</b></li></ul></blockquote></li><li><font face="楷体" color="red" size="5">多模式串匹配算法</font><blockquote><ul><li><b>Trie树</b>，（又称前缀树，字典树，单词查找树）<blockquote><ul><li>Trie这个术语来自于retrieval根据词源学, trie的发明者Edward Fredkin把它读作/‘tri:/ “tree”。但是 ,其他作者把它读作/‘tra1/ “try”。</li></ul></blockquote></li><li><b>AC自动机算法</b>（Aho–Corasick算法）是由Alfred V.Aho和Margaret J.Corasick 发明的<blockquote><ul><li>其实，Trie树跟AC自动机之间的关系，就像单模式串匹配中朴素的串匹配算法，跟KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上罢了。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><p><b>单模式串匹配的算法</b><br>也就是一个串和一个串进行匹配<br><b>多模式串匹配的算法</b><br>是在一个串中同时查找多个串</p><h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>一顿暴力，直接贴代码</p><p>//指针做输入，const修饰避免改动。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">BF</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>text <span class="token comment" spellcheck="true">/*in*/</span> <span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pattern <span class="token comment" spellcheck="true">/*in*/</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>text<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//非法输入</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//位置 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token string">'\0'</span><span class="token operator">!=</span>text<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span>pos<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//text回溯 </span>        <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//pattern回溯 </span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//已经匹配字符长度</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token string">'\0'</span><span class="token operator">!=</span>pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token operator">++</span>sum<span class="token punctuation">;</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">==</span><span class="token function">strlen</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> pos<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">++</span>pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匹配失败    </span><span class="token punctuation">}</span></code></pre><p>分析BF算法：</p><blockquote><ul><li>时间复杂度$O(n*m)$</li><li>空间复杂度$O(1)$</li></ul></blockquote><p>其他补充：</p><blockquote><ul><li>尽管理论上，BF算法的时间复杂度很高，但在实际的开发中，它却是一个比较常用的字符串匹配算法：<blockquote><ul><li>1.实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度大，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</li><li>2.BF算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug 也容易暴露和修复。<b>在工程中，在满足性能要求的前提下，简单是首选。</b>这也是我们常说的<b>KISS（Keep it Simple and Stupid）设计原则</b>。所以，在实际的软件开发中，绝大部分情况下，BF算法就够用了</li></ul></blockquote></li></ul></blockquote><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p><b>联系</b>：RK算法是BF算法的改进，它巧妙借助了我们前面讲过的哈希算法，引入<font face="楷体" color="red" size="5">哈希算法</font>，时间复杂度立刻就会降低。<br><b>难点</b>：设计一个可以应对各种类型字符的哈希算法并不简单</p><p><b>思路</b>:我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（当然我们需要考虑哈希冲突的问题）。比较哈希值是非常快速的，所以效率提高了。<br>不过这又<b>引入一个问题</b>：通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率？<br><b>哈希算法设计技巧</b>：我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。</p><p><b>没有冲突的哈希</b>：我们只需要比较一下模式串和子串的哈希值<br><b>有冲突的哈希</b>：当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。解决方法很简单。当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只<br>需要再对比一下子串和模式串本身就好了。<br>当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。</p><p>总结：哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间<br>复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本<br>身，那时间复杂度就会退化成$O(n*m)$</p><p><b>但一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。</b></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 字符串匹配 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的const底层机制</title>
      <link href="/2020/05/31/2020-05-31-Cplusplus-const/"/>
      <url>/2020/05/31/2020-05-31-Cplusplus-const/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中对C的const关键字增强"><a href="#C-中对C的const关键字增强" class="headerlink" title="C++中对C的const关键字增强"></a>C++中对C的const关键字增强</h1><h2 id="一、问题导入"><a href="#一、问题导入" class="headerlink" title="一、问题导入"></a>一、问题导入</h2><p>背景：<br>我们总说C语言中const修饰的变量看上去似乎是常量，其实是个“冒牌货”，应该叫”常变量”，比如用指针间接赋值，就能改变了。</p><p>代码测试：<br>将指针间接修改变量值的代码放到C语言编译器和C++编译器去测试</p><p>DevC++的C语言编译器</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//demo.c </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<br> <img src="/photos/2020.5.30_31/01.png" width="80%"></p><p>DevC++的C++语言编译器</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//test.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<br> <img src="/photos/2020.5.30_31/02.png" width="80%"></p><p>奇特的结果：<br>我们要是写了这样的函数在银行程序中，要是用不同编译器，那么对账就对不上了。<br>总结：<br>C中的const是个常变量，变量的值能够被间接修改。<br>C++中的const是一个真正的常量！</p><p>Tips：</p><table><tbody><tr><td bgcolor="#FFFF" ff="">以上两次测试，都没有显示warning和error</td></tr></tbody></table><p>那么，我们或许会疑惑：<br>Q：我们说C++中的是一个真正的常量，那为什么，没有C++编译器对我们”用指针间接修改”的行为，没有报warning或者error呢？<br>A：C++要兼容C，所以，它认为这个语法是可以的<br>Q：那么问题又来了，那他既然兼容，那么为什么最后却没改变那个变量的值呢？<br>A：因为C++只是兼容那种语法写法，但是底层的实现却对const关键字进行了加强。</p><h2 id="二、底层原理分析"><a href="#二、底层原理分析" class="headerlink" title="二、底层原理分析"></a>二、底层原理分析</h2><h3 id="1）C-编译器对const做了一些加强，做了一些特殊的处理"><a href="#1）C-编译器对const做了一些加强，做了一些特殊的处理" class="headerlink" title="1）C++编译器对const做了一些加强，做了一些特殊的处理"></a>1）C++编译器对const做了一些加强，做了一些特殊的处理</h3><p>当C++编译器，扫描到常量声明时，它不再像C语言那样，把这个const给它单独分配内存。</p><p>在我们先前的//test.cpp中。<br>C++进行了如下操作：</p><blockquote><ul><li>1）扫描到这一行，const int a=98;<br>C++编译器会把这个<b>变量a</b>放在一个<b>符号表（键值-值对）</b>里面<br><b>此时，并没有分配内存！！！</b><br>注意：这样的话，key和value是定了，不能修改的了。<br>符号表具体的实现和我们的内存中的，栈，堆不是同一套实现机制。<br>有很多常量就都放在这个里面了。<br>Tips：<br>当你去<b>使用</b>这个a的时候，它就给你从符号表里面给你把这个98给拿出来，供你<b>使用</b></li></ul></blockquote><table><tbody><tr><td bgcolor="#FFFF" ff="">注意"使用"一词</td></tr></tbody></table><blockquote><ul><li>2）遇到类似这样的情况，此时才给a变量另外分配一个内存。<br>扫描到这一句p=(int <em>)&amp;a;<br>当你对这个a变量取地址的时候，C++编译器，会为这个a再<b>单独的开辟一块内存空间</b>，然后你把这个内存空间，赋给了p，相当于一个指针P指向了这里。然后你通过</em>p去间接的修改的地址，不再是原来的值（value）,而是我们新开辟的空间的值（注意理解）<br>所以，当你再使用a的时候，你打印的还是98（符号表中的a）<img src="/photos/2020.5.30_31/03.png" width="90%"></li></ul></blockquote><h3 id="2）证明"><a href="#2）证明" class="headerlink" title="2）证明"></a>2）证明</h3><p>我们现在来证明这个开辟的内存空间的存在</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//solution.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*p=%d"</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>打印的是:<br> <img src="/photos/2020.5.30_31/04.png" width="80%"></p><p><b>注意：</b></p><table><tbody><tr><td bgcolor="#FFFF" ff="">C++编译器虽然可能为const常量分配空间，但不会<b>使用</b>其存储空间中的值，除非你用指针操作。</td></tr></tbody></table><h2 id="三、结论和补充"><a href="#三、结论和补充" class="headerlink" title="三、结论和补充"></a>三、结论和补充</h2><p>1）C语言中的const变量<br>C语言中const变量是只读变量，<b>有自己的存储空间</b><br>2）C++中的const常量</p><table><tbody><tr><td bgcolor="#FFFF" ff="">注意：可能分配存储空间,也可能不分配存储空间!</td></tr></tbody></table><p>编译过程中若发现<b>使用常量</b>则直接以符号表中的值替换</p><p>Tips：<br>只有下面两种的时候，它才会分配空间</p><blockquote><ul><li>当const常量为全局，并且需要在其它文件中使用,即使用了<b>extern</b>操作符</li><li>当使用&amp;操作符取const常量的地址，编译过程中若发现对const使用了<b>&amp;操作符</b>，则给对应的常量分配存储空间（兼容C）</li></ul></blockquote><h2 id="四、补充疑问"><a href="#四、补充疑问" class="headerlink" title="四、补充疑问"></a>四、补充疑问</h2><p>Q：那么要是分配内存，C++中那个const的分配内存是在什么时候分配的呢？是在编译器<b>编译阶段</b>，还是在<b>执行阶段</b>分配？</p><table><tbody><tr><td bgcolor="#FFFF" ff="">Ａ：C++中const分配内存的时机，是在编译期间！（记住！）</td></tr></tbody></table><p>证明的代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//test.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a=%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;b=%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用了取地址 </span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;c=%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre> <img src="/photos/2020.5.30_31/05.png" width="80%"><p>结果表明：<br>const int b的地址在a和c之间，符合我们局部变量申请内存的<b>压栈的顺序</b>，<b>它并没有因为，&amp;b这句话写到int c后面，就先分配a，c最后才b</b>，而是，它扫描完之后，看到这里有&amp;b了，就分配地址了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性排序</title>
      <link href="/2020/05/30/2020-05-30-Linear-Sort/"/>
      <url>/2020/05/30/2020-05-30-Linear-Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="三种线性排序"><a href="#三种线性排序" class="headerlink" title="三种线性排序"></a>三种线性排序</h1><h2 id="一、前述"><a href="#一、前述" class="headerlink" title="一、前述"></a>一、前述</h2><p>《算法导论》中提到有定理表明：</p><blockquote><ul><li>任何比较排序在最坏的情况下都要经过$\Omega(nlogn)$次比较</li></ul></blockquote><p>下面讨论三种<b>线性时间复杂度</b>的排序算法。<br>原因：这三种算法是用<b>运算</b>而不是<b>比较</b>来确定排序顺序的，所以能够突破这个定理的桎梏</p><p>排序算法四问：</p><blockquote><ul><li><b>1)时间复杂度</b></li><li><b>2)空间复杂度</b></li><li><b>3)排序是否原地</b><blockquote><ul><li><b>原地排序</b>：指不需要开辟额外空间</li></ul></blockquote></li><li><b>4)稳定性</b><blockquote><ul><li><b>稳定的排序</b>：具有相同值的元素在输出数组中的相对次序与他们在输入数组中的相对次序<b>相同</b></li><li><b>意义</b>：只有当进行排序的数据还附带<b>“卫星数据”</b>时才比较重要。  eg.我们排序的是结构体的整数值，而整数值相同的，可能他的字符串不同。</li></ul></blockquote></li></ul></blockquote><h2 id="二、计数排序（counting-sort）读音是第4声"><a href="#二、计数排序（counting-sort）读音是第4声" class="headerlink" title="二、计数排序（counting sort）读音是第4声"></a>二、计数排序（counting sort）读音是第4声</h2><h3 id="1-假设和操作"><a href="#1-假设和操作" class="headerlink" title="1.假设和操作"></a>1.假设和操作</h3><h4 id="输入数据假设"><a href="#输入数据假设" class="headerlink" title="输入数据假设"></a>输入数据假设</h4><p>假设n个输入元素中的每个元素都是在[min,max]区间的一个<b>整数</b>。<br>排序快的原因：</p><blockquote><ul><li>进行了上面的假设</li><li>用空间换时间</li></ul></blockquote><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><blockquote><ul><li>1·建立一个长度为max-min+1的统计数组，元素初始化为0</li><li>2·每次扫描进数据，那么对应的统计数组的值+1（数组每一个下标位置的值，代表了数列中对应整数出现的次数）<b>（计数一词的来源）</b></li><li>3·遍历统计数组，输出数组元素的下标值，元素的值是几，就输出几次</li><li>4·如果排序的带有<b>“卫星数据”</b>,则需要进行第4步————此举，保证了计数排序的稳定性<blockquote><ul><li>对已经填充完的统计数组，做一下变形——具体的请见下面场景</li><li>根据情况，选择正向或者反向遍历统计数组</li></ul></blockquote></li></ul></blockquote><p>Tips：计数排序的稳定性很重要的另一个原因是：计数排序经常会被用作基数排序算法的一个子过程，为了使基数排序正确执行，计数排序必须是稳定的。</p><p>创造场景如下：</p><blockquote><ul><li>假设有一个企业的招聘系统规则如下<blockquote><ul><li>申请者需要投递简历，写好姓名，将得到一个原始的排名Ranking</li><li>为了激励大家投递简历，发布了一条通知,我们的排名（Ranking）依据两个维度来给申请者面试名额<blockquote><ul><li>1.笔试成绩高者，排名（Ranking）高</li><li>2.笔试成绩相同者，公司会给先投递简历的人高的排名（Ranking）<br>此处体现了，排序的稳定性需求</li><li>我们最后会将排名（Ranking）前4的申请者的名字（name）打印出来<br>名字是我们要排序的成绩（grade）的卫星数据</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><p>申请者的结构体设计如下</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Apply<span class="token punctuation">{</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> grade<span class="token punctuation">;</span><span class="token punctuation">}</span>Ranking<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>显然，我们的计数排序是根据结构体的元素，grade来排名。<br>此外，为了容易说明计数排序，我们假设，笔试成绩范围是0-10分<br>投递简历如下图：<br> <img src="/photos/2020.5.30_31/1.png" width="80%"><br> 笔试完了，成绩如下图：<br><img src="/photos/2020.5.30_31/2.png" width="80%"><br>请按照规则给上面排序，注意：小橙和小青的成绩都是6<br>操作：<br>1·建立一个长度为11的统计数组，元素初始化为0，表示我们的成绩为0-10<br>2·每次扫描进数据，那么对应的统计数组的值+1<br>显然获得统计数组如下图：<br><img src="/photos/2020.5.30_31/3.png" width="90%"><br>3.暂时，不需要输出<br>4.对统计数组进行变形：<br>方法，从倒数第2位开始，反向遍历统计数组，a[i]=a[i+1]+a[i];<br>相加的目的,是为了让统计数组存储的元素值,等于相应grade的排名的最终排序位置。<br><img src="/photos/2020.5.30_31/4.png" width="90%"><br>5.接下来,我们创建输出数组,长度和输入数组一致。<br>然后</p><table><tbody><tr><td bgcolor="#FFFF" ff="">注意1）从后往前遍历</td></tr></tbody></table>原先的输入数组小青，成绩6，查统计数组,值为2（有2个同成绩的），查变形后数组，放输出数组<b>第5位</b>Tips：查到统计数组值为2，我们在放完小青到输出数组之后，需将变形后的数组的值减1，变成了4<table><tbody><tr><td bgcolor="#FFFF" ff="">注意2）从5变成4,代表着下次再遇到6分的成绩时,最终排名是第4。（这就保证了计数排序的稳定性!）</td></tr></tbody></table><p>小蓝，成绩7,查统计数组,值为1（唯一），查变形后的数组，放输出数组的<b>第3位</b><br>小绿，成绩5,查统计数组,值为1（唯一），查变形后的数组，放输出数组的<b>第6位</b><br>小黄，成绩8,查统计数组,值为1（唯一），查变形后的数组，放输出数组的<b>第2位</b></p><p>小橙，成绩6,查统计数组,值为2（有2个同成绩的），查变形后数组，知放输出数组<b>第4位</b><br>我们在放完小橙到输出数组之后，需将变形后的数组的值，减1，变成了3</p><p>小红,成绩9,查统计数组,值为1（唯一），查变形后的数组，知放输出数组的<b>第1位</b> </p><p>排序后结果（如图，保证了卫星数据的稳定性）：<br><img src="/photos/2020.5.30_31/5.png" width="90%"></p><h3 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2.算法分析"></a>2.算法分析</h3><blockquote><ul><li>时间复杂度：$O(n+m)$    其中m是原始数组的整数范围</li><li>空间复杂度：$O(n+m)$</li><li>是否原地排序：否</li><li>稳定性：稳定</li><li>数据结构：数组，hash</li></ul></blockquote><p>Tips：有人也把统计数组的每个位置，叫做一个个桶，但我们暂时不这么叫，免得大家将桶排序和计数排序弄混了</p><h3 id="3-局限性"><a href="#3-局限性" class="headerlink" title="3.局限性"></a>3.局限性</h3><blockquote><ul><li>1.当输入数组元素最大最小值差距过大时<br>比如给定20个随机整数,范围在0到1亿之间,这时若使用计数排序,需创建长度为1亿的数组。严重浪费空间,且时间复杂度也随之升高。<br>解决方案：见桶排序</li><li>2.当输入数组元索不是整数，如字符，浮点数<blockquote><ul><li>如果数列中的元素都是小数,比如25.23 ,或是0.01这样子,无法创建对应的统计数组。<br>解决方案1：假如是0.3,0.13,0.001,0.22  我们可以将他们全乘1000，然后就转换为计数排序，输出的时候，记得除回来<br>解决方案2：见桶排序</li><li>如果数列中的元素都是字符或字符串,比如abc,b,c<br>解决方案1：借助字符的ASCII码，按位赋权，转换hash为数字，再排序<br>解决方案2：见基数排序，借助字符的ASCII码。</li></ul></blockquote></li><li>4.如果，输入的元素是大整数，比如15位长的号码1234567894554541,可是,15位长的号码有多少种组合?这要建立一个大得不可想象的数组,才能装下所有可能出现的15位长的号码，很不划算!<br>解决方案：见基数排序（思想：减而治之）</li><li>5.其他————碰到了再补充，总之，要灵活运用，而不是将某种算法运用场景当做教条，场景只是帮助更好的理解算法的一种方式。</li></ul></blockquote><h2 id="三、基数排序（Radix-sort）读音是第1声"><a href="#三、基数排序（Radix-sort）读音是第1声" class="headerlink" title="三、基数排序（Radix sort）读音是第1声"></a>三、基数排序（Radix sort）读音是第1声</h2><h3 id="1-操作"><a href="#1-操作" class="headerlink" title="1.操作"></a>1.操作</h3><p>需求：为如下一组英文单词排序<br><img src="/photos/2020.5.30_31/6.png" width="90%"><br>操作：我们把排序工作拆分成多个阶段,每一个阶段只根据一个字符(基数排序，基字的由来)进行计数排序, 一共排序k轮, k是元素长度。<br>如何将这些字符串按照字母顺序排序呢?<br>具体的<br>由于每个字符串的长度是3个字符,我们可以把排序工作拆分成3轮</p><blockquote><ul><li>第一轮:按照最低位字符排序。排序过程使用计数排序,把字母的ascii码对应到数组下标，第1轮排序结果如下:<img src="/photos/2020.5.30_31/7.png" width="90%"></li></ul></blockquote><blockquote><ul><li>第二轮:<b>在第一轮排序结果的基础上</b>,按照第二位字符排序，第2轮排序结果如下:<img src="/photos/2020.5.30_31/8.png" width="90%"></li></ul></blockquote><table><tbody><tr><td bgcolor="#FFFF" ff="">注意：这里使用的计数排序必须是稳定排序,这样才能保证第1轮排出的先后顺序在第2轮还能继续保持！</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FFFF" ff="">比如，在第1轮排序后,元素uue在元素yui之前。那么第二轮排序时,两者的第二位字符虽然同样是u,但先后顺序一定不能变,否则第1轮排序就白做了。</td></tr></tbody></table><blockquote><ul><li>第三轮：同理，略。</li></ul></blockquote><blockquote><ul><li>基数排序(Radix Sort)：形如这样把字符串元素按位拆分,每一个基位进行一次稳定性的排序的算法,就是基数排序<br>基数排序既可以<b>从高位优先</b>进行排序（Most Significant Digit first ,简称MSD ）<br>也可以<b>从低位优先</b>进行排序（Least Significant Digit first ,简称LSD）<br>刚才我们所举的例子,就是典型的LSD方式的基数排序。</li></ul></blockquote><h3 id="2-疑问"><a href="#2-疑问" class="headerlink" title="2.疑问"></a>2.疑问</h3><p>问：如果排序的字符串长度不规则呢?  比如有的字符串是5位，有的是3位</p><pre><code>bananaappleorangeapehe</code></pre><p>毛主席说过，<b>没有条件，我们就创造条件</b><br>创造条件：<br>我们以最长的字符串为准，其他长度不足的字符串，在<b>末尾补0</b>即可</p><pre><code>bananaapple0orangeape000he0000</code></pre><p>在排序时,我们把字符0当做是比a更小的字符,排序结果如下:</p><pre><code>ape000apple0bananahe0000orange</code></pre><h3 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="3.算法分析"></a>3.算法分析</h3><blockquote><ul><li>时间复杂度：$O(k(n+m))$    其中m是原始数组的整数范围<br>由于字符串元素的长度k是一个固定常量，所以我们认为这个是一个线性的排序算法。</li><li>空间复杂度：$O(n+m)$    至于空间复杂度，由于基数排序的辅助数组是反复重用的，所以基数排序的空间复杂度和计算排序一样。</li><li>是否原地排序：否</li><li>稳定性：稳定</li><li>数据结构：数组，hash</li></ul></blockquote><table><tbody><tr><td bgcolor="#FFFF" ff="">注意点：</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FFFF" ff="">1.上面的算法时间复杂度分析是不够完善的，其实上面的是以计数排序这种稳定排序作为基数排序的子过程的复杂度分析。基数排序，其实主要是强调，我们对待一些排序，可以按位（比如，我们二进制中，按照以2为基的任何位），来分别排序。</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FFFF" ff="">2.推而广之：基数排序的子过程，可以是任何具有稳定性的排序算法（注意点）eg.插入排序，折半插入排序，冒泡排序</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FFFF" ff="">Tips:其实，基数排序的算法的时间复杂度分析依赖于我们所使用的稳定的排序算法！！！</td></tr></tbody></table><h2 id="四、桶排序（bucket-sort）"><a href="#四、桶排序（bucket-sort）" class="headerlink" title="四、桶排序（bucket sort）"></a>四、桶排序（bucket sort）</h2><h3 id="1-假设和操作："><a href="#1-假设和操作：" class="headerlink" title="1.假设和操作："></a>1.假设和操作：</h3><blockquote><ul><li>碎碎念：桶排序同样是一种线性时间的排序算法。类似于计数排序所创建的<b>统计数组</b>，桶排序需要创建<b>若干个桶</b>来协助排序。这也大概是为什么有的人，将计数排序中的统计数组的叫做一个个桶的原因吧，然后推而广之，也在基数排序中叫桶<br>殊不知：有时就是这样的叫法把初学者弄混了，不知道，是不是有桶的都叫桶排序？</li></ul></blockquote><p>其实，《算法导论》一书中，并没有把计数排序和基数排序中的统计数组叫桶…</p><p>但是，其实桶排序体现的是一种思想，我们不用纠结的是”桶”到底是什么，我们需要的是根据实际情况去选择合适的数据结构去存储，实现这个抽象的”桶”，所以，我们也将计数和基数排序中的统计数组算做是”桶”点一种实现方式吧。</p><p>与计数排序相似，因为对输入数据进行了某种假设，桶排序的速度也很快。<br>假设：输入数据服从<b>均匀分布</b></p><p>那么,桶排序当中所谓的”桶”，又是什么概念呢?<br>每一个桶(bucket)代表一个区间范围,里面可以承载一个或多个元素。</p><blockquote><ul><li>操作：<blockquote><ul><li>第一步，就是创建这些桶,确定每一个桶的区间范围</li><li>第二步，将创建这些桶,分别都进行排序处理（由于，数据满足均匀分布，所以，我们的每个桶放的元素应该都差不多一样多，也就是均匀）</li><li>第三步，合并桶，进行输出</li></ul></blockquote></li></ul></blockquote><h3 id="2-算法分析-1"><a href="#2-算法分析-1" class="headerlink" title="2.算法分析"></a>2.算法分析</h3><p>假设原始数列有n个元素,分成m个桶, 平均每个桶的元素个数为n/m。<br>下面我们来逐步分析算法复杂度:<br>第一步，求数列最大最小值,运算量为n。<br>第二步，创建空桶,运算量为m。<br>第三步，遍历原始数列,运算量为n。<br>第四步，在每个桶内部做排序,若是使用了$0(nlogn)$的排序算法,所以运算量为<br>$n/m * log(n/m)* m$<br>第五步,输出排序数列,运算量为n。<br>加起来,总的运算为$3n+m+ n/m * log(n/m)* m = 3n+m+ n(logn-logm)$<br>去掉系数,时间复杂度为:<br>$O(n+m+n(logn-logm))$</p><p>空间复杂度:<br>空桶占用的空间+数列在桶中占用的空间=$O(n+m)$</p><blockquote><ul><li>时间复杂度：$O(n+m+n(logn-logm))$</li><li>空间复杂度：$O(n+m)$    </li><li>是否原地排序：否</li><li>稳定性：若是桶内使用不稳定的排序，则不稳定，但是桶与桶之间是稳定的</li><li>数据结构：数组，链表，堆…看场景</li></ul></blockquote><table><tbody><tr><td bgcolor="#FFFF" ff="">Tips：分析</td></tr></tbody></table><blockquote><ul><li>时间复杂度：<blockquote><ul><li>最坏n方（一个桶)）</li><li>最好为n（n个桶而且值排列均匀）</li></ul></blockquote></li><li>空间复杂度：<blockquote><ul><li>其实，要是想要空间复杂度最好，得用链表，但是那样时间复杂度就做不到最好</li></ul></blockquote></li></ul></blockquote><h2 id="五、联系和总结"><a href="#五、联系和总结" class="headerlink" title="五、联系和总结"></a>五、联系和总结</h2><p>总的来说，计数排序，基数排序，桶排序都是用的空间换取时间的思想。<br>另外，我们的计数排序和基数排序都可以看做是桶排序，”桶思想”的一种特例。</p><blockquote><ul><li>由于，桶排序的复杂度分析很依赖于具体的数据，我们常用的反而是计数排序和基数排序。</li><li>从桶排序的算法分析中，我们需要知道的是，没有绝对高效的算法，只有合适的算法应用场景！！！</li><li>总的说来，算法的设计，一般体现的是用时间换空间，或者空间换时间。</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言和C++变量的命名规则</title>
      <link href="/2020/05/29/2020-05-29-The-Rules-Of-Variable-Name/"/>
      <url>/2020/05/29/2020-05-29-The-Rules-Of-Variable-Name/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言和C-变量命名规则探讨"><a href="#C语言和C-变量命名规则探讨" class="headerlink" title="C语言和C++变量命名规则探讨"></a>C语言和C++变量命名规则探讨</h1> <img src="/photos/2020.5.29/title_one.jpg" width="80%"><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><blockquote><ul><li>不能是C语言或者C++的标识符。</li><li>区分大小写</li><li>变量的第1个字符必须是大小写字母或者下划线。</li><li>即，除去第1个字符之外的其他字符是大小写字母，下划线，或数字。 </li></ul></blockquote><p><strong>疑问</strong>：为什么，第3点要求看上去这么奇怪？<br>为什么，不直接说，是直接由大小写字母，下划线，数字组成就好了，为何要强调第1个字符，不能是数字？<br>看上去，一点都不对称，没有美感</p><p><strong>解释</strong>:<br>想象一下，定义这样一个变量<br>int 1=9;//变量名字，要是叫1，那么我们的程序，难道以后，我用1就是9？多尴尬</p><p>反观<br>char c=’d’;<br>char D=’c’;<br>这样的多好，原因是：<br>字符在C语言和C++中是有单引号’’围着的<br>字符串是有双引号””围着的</p><p>或许，创造者在变量名取名规则的时候，首先是考虑了<br>1)大小写字母，毕竟是人家母语，要是计算机语言和母语由类似之处，多好。<br>2)数字，毕竟，阿拉伯数字享誉全球。<br>3)下划线，ummm，或许是为了今后的下划线命名法？？？疑问。。</p><p>然后发现，前面那样int 1=9;这样奇怪的语句，就规则强化了</p><h2 id="工程上主流的变量命名法"><a href="#工程上主流的变量命名法" class="headerlink" title="工程上主流的变量命名法"></a>工程上主流的变量命名法</h2><ul><li>下划线命名法（C语言软件设计师常用）</li><li>驼峰命名法（Java软件设计师常用）</li><li>帕斯卡命名法</li><li>匈牙利名</li></ul><table><tbody><tr><td bgcolor="#FFFF" ff="">（——————未完待续）</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大端和小端存储</title>
      <link href="/2020/05/29/2020-05-29-Big-Endian-little-Endian/"/>
      <url>/2020/05/29/2020-05-29-Big-Endian-little-Endian/</url>
      
        <content type="html"><![CDATA[<h2 id="引子："><a href="#引子：" class="headerlink" title="引子："></a><strong>引子</strong>：</h2><p>《格列夫游记》一书中讲到，格列佛在小人国中，遇到了这样一件事情：</p><blockquote><p> 小人国的人纠结于吃鸡蛋的时候，先打破鸡蛋的小端还大端，原来，在这之前所有人都认为,吃鸡蛋前,原始的方法是打破鸡蛋较大的一端。可是当今皇帝的祖父小时候吃鸡蛋,一次按古法打鸡蛋时碰巧将一个手指弄破了,因此他的父亲,当时的皇帝，就下了一道敕令,命令全体臣民吃鸡蛋时打破鸡蛋较小的一端,违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱,其中一个皇帝送了命,另一个丢了王位。关于这一争端,曾出版过几百本大部著作,不过大端派的书一直是受禁的,法律也规定该派的任何人不得做官。</p></blockquote><p>在计算机界，也有一个类似的大端小端之争，但是并没有像小人国那般，原先我们虽然在纠结选大端还是小端存储？但是随着计算机的发展，历史告诉我们，这些都是合理的，但是要在计算机间合理通信或者理解计算机底层的时候，你自己记得转换就好了。</p><h1 id="大端和小端存储"><a href="#大端和小端存储" class="headerlink" title="大端和小端存储"></a>大端和小端存储</h1><h2 id="一．概念"><a href="#一．概念" class="headerlink" title="一．概念"></a>一．概念</h2><p>大端：指低字节存储在高地址。<br>小端：指低字节存储在低地址。</p><p><strong>记忆方法：</strong></p><table><tbody><tr><td bgcolor="#FFFF" ff="">小端说：我就是个低低（弟弟）</td></tr></tbody></table><p>下图描述了——大端存储（低字节存储在内存高地址了）：<br> <img src="/photos/2020.5.29/1.png" width="80%"></p><p>下图描述了——小端存储（低字节存储在内存低地址了）：：<br> <img src="/photos/2020.5.29/2.png" width="80%"></p><h2 id="二．具体的，大端法和小端法的应用"><a href="#二．具体的，大端法和小端法的应用" class="headerlink" title="二．具体的，大端法和小端法的应用"></a>二．具体的，大端法和小端法的应用</h2><p>有的产品用的大端法，有的产品则是小端法。<br>PS:这个大端和小端并没有严格按照企业界限来区分，因为有的企业，它在之前采用的处理器，可能是大端，但是后面的产品中改变了采用的处理器，可能就采用小端法了。<br>前沿：许多比较新的微处理器使用双端法，也就是说可以把它们配置成作为大端或者小端的机器运行。</p><h2 id="三．大端法和小端法导致的问题："><a href="#三．大端法和小端法导致的问题：" class="headerlink" title="三．大端法和小端法导致的问题："></a>三．大端法和小端法导致的问题：</h2><h3 id="1）网络应用程序数据传输"><a href="#1）网络应用程序数据传输" class="headerlink" title="1）网络应用程序数据传输"></a>1）网络应用程序数据传输</h3><p>在采用不同大小端存储的机器之间通过网络传送二进制数据时候，会导致采用不同大小端存储方式的数据的字节变成反序。<br>解决方案：网络应用程序的代码编写，必须遵循已建立的关于字节顺序的规则（第一处：网络传输规定了，网络字节序（它采用的大端））。<br>第2处，你的机器发送报文前，需要将你的内部表达转换成网络标准。<br>第3处，你的机器接受报文时候，需要根据你的机器，将网络标准转换为你的内部表示。。</p><p>网络字节序<br>网络上传输的数据都是字节流,对于一个多字节数值，在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;<br>UDP/TCP/IP协议规定:<br>把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;</p><p>而在发送端发送数据时，发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);<br>由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;所以说,网络字节序是大端字节序;</p><p>比如,我们经过网络发送整型数值0x12345678时,在80x86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数将其转换成大端法存放的数值;</p><p>常见CPU的宇节序<br>大端（big Endian）: PowerPC、IBM、 Sun<br>小端（little Endian）:x86、DEC<br>ARM既可以工作在大端模式,也可以工作在小端模式。</p><h3 id="2）反汇编的时候"><a href="#2）反汇编的时候" class="headerlink" title="2）反汇编的时候"></a>2）反汇编的时候</h3><table><tbody><tr><td bgcolor="#FFFF" ff="">（——————未完待续）</td></tr></tbody></table><h2 id="四．如何判别大端和小端"><a href="#四．如何判别大端和小端" class="headerlink" title="四．如何判别大端和小端"></a>四．如何判别大端和小端</h2><p>1）我们可以根据C语言中的，联合体来判断，该系统是大端还是小端。<br>因为，联合体变量总是从低地址存储。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">union</span> test    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">;</span>        <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>demo<span class="token punctuation">;</span>    demo<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">0x01ffff03</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x03</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这个机器是小端存储！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这个机器是大端存储！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"无法判断机器类型！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>显然，<br>要是小端存储，那么（低字节）0x03在低地址，<br>要是大端存储，那么（高字节）0x00在低地址。<br>所以，打印出3就是小端存储。打印出0那就是大端存储。<br>笔者的电脑是采用的intel的X86CPU，是小端存储。<br>  <img src="/photos/2020.5.29/3.png" width="80%"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编译器底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言优先级和结合性记忆</title>
      <link href="/2020/05/28/2020-05-28-C_priority_and_associative_memory/"/>
      <url>/2020/05/28/2020-05-28-C_priority_and_associative_memory/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言优先级和结合性记忆"><a href="#C语言优先级和结合性记忆" class="headerlink" title="C语言优先级和结合性记忆"></a>C语言优先级和结合性记忆</h1><p><strong>前述</strong>：以前以为，记忆C语言的优先级和结合性就像孔乙己记忆“回”字的四种写法一样有些没必要，对于技术，简洁即美。但以下场景，记忆C语言的优先级结合性还是有一定好处<br><strong>场景</strong>：</p><blockquote><ul><li>记忆一些特定的优先级和结合性，能够帮助从编译器角度来快速识别多级指针和数组指针和函数指针判定指针类型。</li><li>某些项目的遗留代码中有一些编程风格不好的片段，总是不写括号，遇到就需要查书，对研究别人代码，有一定影响。记忆优先级和结合性，能够降低开发中重构已有代码的难度。</li><li>有的相关试题中，有考优先级的题目的存在。（考优先级不是目的，而是为了解决那些风格不好的遗留代码）</li><li>由于编译器语法分析阶段的设计原理，其他语言的优先级也可以在此基础上记忆。<blockquote><ul><li>C语言的优先级，再添加上一些C++本身的运算符，则很容易转换到记忆C++的优先级</li><li>Java的运算符的优先级和C语言相似</li></ul></blockquote></li></ul></blockquote><p><strong></strong></p><center><strong>优先级从高到低，分为15级</strong></center><br><img src="/photos/2020.5.28/2020_5.28_1.jpg" width="80%"><br><img src="/photos/2020.5.28/2020_5.28_2.jpg" width="80%"><p></p><h2 id="优先级记忆"><a href="#优先级记忆" class="headerlink" title="优先级记忆"></a>优先级记忆</h2><table><tbody><tr><td bgcolor="#FFFF" ff="">初-单-算-移-关        （出箪蒜一罐）</td></tr></tbody></table>  <table><tbody><tr><td bgcolor="#FFFF" ff="">位-逻-三-赋-逗        （味落三伏豆）</td></tr></tbody></table> <p>//箪—意指古代盛饭用的圆形竹器</p><blockquote><p>记忆场景：<br>每年三伏天农作时期，要为田间劳作者送饭，送饭者专门用箪盛着食物前往，还专门为其中一个很喜欢吃大蒜的劳作者带了一罐蒜解馋。后来，劳作者吃着发现，今年的三伏天的黄豆也格外美味。</p></blockquote><p>解释：<br>初：初级运算符<br>单：单目运算符<br>算：算数运算符（包含2个优先级）<br>移：移位运算符<br>关：关系运算符（包含2个优先级）</p><p>位：位运算（除去，位运算中的单目运算符~ 包含3个优先级）<br>逻：逻辑运算符（包含2个优先级）<br>三：三目运算符<br>赋：赋值运算符<br>逗：逗号运算符</p><h2 id="结合性记忆"><a href="#结合性记忆" class="headerlink" title="结合性记忆"></a>结合性记忆</h2><table><tbody><tr><td bgcolor="#FFFF" ff="">单三赋    从右左</td></tr></tbody></table> <p>除以上规则以外,还有一点。<br>标准的C语言编译器对运算符的解析遵循“最大贪婪”规则。</p><h2 id="“最大贪婪”规则"><a href="#“最大贪婪”规则" class="headerlink" title="“最大贪婪”规则"></a><strong>“最大贪婪”规则</strong></h2><p>当C语言编译器对源程序进行词法分析时，如果运算符的下一个符号还是运算符，并且能和前一个运算符构成一个新的合法运算符时，编译器的词法分析器必须将其解析为两个运算符符号构成的新的运算符。</p><p>举一个没太大实际意义的例子来辅证，例如: x=z+++y;<br>是按照x=z+（++y）;来计算，还是按照x=（z++）+y;来计算呢?<br>根据C编译器的“最大贪婪”规则,是按照x=（z++）+y;来计算，而不是按照x=z+（++y）来计算<br>可以验证</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> z<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>x<span class="token operator">=</span>z<span class="token operator">++</span><span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出结果为8，而不是9</span><span class="token comment" spellcheck="true">//考点：C编译器的“最大贪婪”规则</span></code></pre><h2 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h2><ul><li><p>记忆第一优先级中的和第二优先级</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个数组指针，指向的类型是int (*)[3]</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个指针数组，里面的是int *类型的指针</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个二级指针，指向的类型是int *</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这是一个函数指针，指向的类型是int (*)(int,int)</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个返回值为指针的函数</span></code></pre></li><li><p>比格基地笔试题</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//以下程序的k最终值是：</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>k <span class="token operator">*</span><span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//答:90</span><span class="token comment" spellcheck="true">//解释  =是赋值运算符 *=是赋值运算符  +是算数运算符 </span><span class="token comment" spellcheck="true">//“出箪蒜一罐,味落三伏豆”知，算数运算符优先级高，先算i+j</span><span class="token comment" spellcheck="true">//考点：编程语言的优先级</span></code></pre></li><li><p>360公司笔试题</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> m<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>  <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token operator">=</span><span class="token operator">&amp;</span>m<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//“出箪蒜一罐,味落三伏豆”知,关系运算符==的优先级比赋值运算符=高，知i=0</span>  i<span class="token operator">=</span>p<span class="token operator">==</span><span class="token operator">&amp;</span>m<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//(-*p)中，-和*都是单目运算符，结合性是“单三赋，从右左”，所以，相当于(-n)</span>  j<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%d,j=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出为 i=0,j=7</span><span class="token comment" spellcheck="true">//考点：编程语言的优先级,结合性</span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数暴力到欧拉筛法</title>
      <link href="/2020/05/28/2020-05-28-Prime_sieve_algorithm/"/>
      <url>/2020/05/28/2020-05-28-Prime_sieve_algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="素数相关算法详解"><a href="#素数相关算法详解" class="headerlink" title="素数相关算法详解"></a>素数相关算法详解</h1><p>本文讲解了<strong>素数</strong> 的定义<br>并且从素数的暴力算法一路优化到了欧拉筛法</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><blockquote><ul><li>1.<a href="#jump010">素数的定义</a></li><li>2.<strong>素数相关算法</strong><blockquote><ul><li><a href="#jump021">判别素数的朴素法（暴力法）</a><blockquote><ul><li>算法原理</li><li>实现(轻微优化)</li></ul></blockquote></li><li><a href="#jump022">埃塞托尼亚筛</a><blockquote><ul><li>算法原理</li><li>实现1</li><li>实现2：对实现1的优化</li></ul></blockquote></li><li><a href="#jump023">欧拉筛</a><blockquote><ul><li>算法原理</li><li>实现 </li></ul></blockquote></li></ul></blockquote></li><li>3.==总结==</li></ul></blockquote><h2 id="1-素数的定义"><a href="#1-素数的定义" class="headerlink" title="1.素数的定义"></a>1.素数的定义</h2><p>维基百科定义：<br><strong>质数</strong>（Prime number），又称<strong>素数</strong><br><strong>指在大于1的自然数中</strong>，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。大于1的自然数若不是素数，则称之为<strong>合数</strong>（也称为<strong>合成数</strong>）。<br> <strong>Tips：</strong><br>1.有的教材上：（指在大于1的自然数中）这一点没有强调，导致容易误解！！！<br>也是经常弄晕一些人对素数的理解的原因。<br>2.所以：<table><tbody><tr><td bgcolor="#FFFF" ff="">1既不是素数也不是合数！！！</td></tr></tbody></table></p><h2 id="2-素数相关算法"><a href="#2-素数相关算法" class="headerlink" title="2.素数相关算法"></a>2.素数相关算法</h2><h3 id="判别素数的朴素法（暴力法）"><a href="#判别素数的朴素法（暴力法）" class="headerlink" title="判别素数的朴素法（暴力法）"></a>判别素数的朴素法（暴力法）</h3><span id="jump021"></span><h5 id="1）算法原理："><a href="#1）算法原理：" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>不管三七二十一<br>根据素数定义就是一顿暴力。</p><h5 id="2）实现-轻微优化"><a href="#2）实现-轻微优化" class="headerlink" title="2）实现(轻微优化)"></a>2）实现(轻微优化)</h5><h6 id="代码段："><a href="#代码段：" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//0表示不是素数，1表示是素数 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//表示根号n向下取整 </span>    <span class="token keyword">int</span> sqrt_num<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>sqrt_num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是素数 </span><span class="token punctuation">}</span></code></pre><h3 id="埃塞托尼亚筛"><a href="#埃塞托尼亚筛" class="headerlink" title="埃塞托尼亚筛"></a>埃塞托尼亚筛</h3><span id="jump022"></span><h5 id="1）算法原理：-1"><a href="#1）算法原理：-1" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>1&gt;假设从2-N全是素数<br>2&gt;从2开始枚举，对于每个素数，我们筛去它的所有倍数，最后我们剩下来的就都是素数<br><strong>关键点</strong>：<br>从2开始枚举到某个数字A，如果a没有被前面步骤的数筛去，那么a一定是素数。<br>原因：<br><strong>如果A（A&gt;2）是合数</strong>，则<strong>A=素数×另一个数</strong><br><strong>PS：这个素数必定小于A，所以会被我们前面筛出来的素数筛掉</strong></p><h5 id="2）实现"><a href="#2）实现" class="headerlink" title="2）实现"></a>2）实现</h5><p>用一个标记数组实现<br>枚举的过程中，筛的过程就是依次改变这个标记数组的过程</p><h5 id="实现1：按照思路直接筛，筛的过程如下图红色箭头所示"><a href="#实现1：按照思路直接筛，筛的过程如下图红色箭头所示" class="headerlink" title="实现1：按照思路直接筛，筛的过程如下图红色箭头所示"></a>实现1：按照思路直接筛，筛的过程如下图红色箭头所示</h5><img src="/photos/2020.5.28/2020_5.26_1.png" width="80%"><h6 id="代码段：-1"><a href="#代码段：-1" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Eratosthenes_one.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数i，并且Num+1</span>            <span class="token comment" spellcheck="true">//注意这种写法，本来应该用i*j&lt;=(maxn-1)判断就好了</span>            <span class="token comment" spellcheck="true">//但是要避免i*j的结果溢出int,所以改为j&lt;=((maxn-1)/i)</span>            <span class="token comment" spellcheck="true">//maxn-1是因为标记数组范围本来就只有0-100004 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                TagArray<span class="token punctuation">[</span>j<span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//筛去素数i的倍数 </span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+4中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="实现2："><a href="#实现2：" class="headerlink" title="实现2："></a>实现2：</h5><p>在实现1的基础上，我们发现，如图中蓝色部分的，被重复筛了。我们容易观察出，如果要减少筛的次数，我们可以从质数的平方往后筛（优化）<br><img src="/photos/2020.5.28/2020_5.26_2.png" width="80%"></p><h6 id="代码段：-2"><a href="#代码段：-2" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Eratosthenes_two.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数i，并且Num+1</span>            <span class="token comment" spellcheck="true">//注意这种写法，本来应该用i*j&lt;=(maxn-1)判断就好了</span>            <span class="token comment" spellcheck="true">//但是要避免i*j的结果溢出int,所以改为j&lt;=((maxn-1)/i)</span>            <span class="token comment" spellcheck="true">//maxn-1是因为标记数组范围本来就只有0-100004 </span>            <span class="token comment" spellcheck="true">//(修改处)将j=2改为了j=i，这样就能少筛掉表格中那些蓝色部分了 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                TagArray<span class="token punctuation">[</span>j<span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//筛去素数i的倍数 </span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+4中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><span id="jump023"></span><p><strong>由来</strong>：<br>由于埃塞托尼亚筛筛的时候重复筛（比如下面的）了，使得算法效率还不够好，所以，我们改进一下，我们继续观察先前的图，发现埃塞托尼亚筛是<strong>竖着筛</strong>，我们似乎也难以优化这种筛法了，我们转换一下思路——<strong>横着筛</strong></p><h5 id="1）算法原理：-2"><a href="#1）算法原理：-2" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>思路：在埃氏筛的一种优化<br>任何合数都能写成一个素数乘一个数（显然这个素数不一定是唯一的）<br>//举个例子：12=2<em>6=3</em>4（2和3都是素数）<br>所以，任何合数都有一个<strong>最小的质因数</strong></p><table><tbody><tr><td bgcolor="#FFFF" ff="">用这个"最小质因数"来判断什么时候不用继续筛下去</td></tr></tbody></table><p>那么如何实现呢？<br>欧拉研究发现，我要是<strong>横着筛</strong>就会比前面那种只优化掉蓝色部分的埃氏筛还快</p><img src="/photos/2020.5.28/2020_5.26_3.png" width="80%"><p><strong>注意</strong>：这里是横着筛，此外图中箭头从<strong>橙色出发（包括该点）</strong>往右的所有我都不筛<br>具体实现方法是用的一个<strong>break</strong>实现的。</p><h5 id="2）实现-1"><a href="#2）实现-1" class="headerlink" title="2）实现"></a>2）实现</h5><h6 id="代码段：-3"><a href="#代码段：-3" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Euler.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数，并且Num+1    </span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>Num<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//一进来,不管三七二十一，先筛掉一个先</span>            TagArray<span class="token punctuation">[</span>i<span class="token operator">*</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//判别i是Prime数组中某个的倍数，则跳出，</span>                <span class="token comment" spellcheck="true">//这行后面的也不用筛     </span>                <span class="token keyword">break</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>              <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+5-1中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
