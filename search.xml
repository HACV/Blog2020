<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组的初始化</title>
      <link href="/2020/06/02/C-Array-init/"/>
      <url>/2020/06/02/C-Array-init/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的不完全初始化"><a href="#数组的不完全初始化" class="headerlink" title="数组的不完全初始化"></a>数组的不完全初始化</h1><h2 id="一、问题由来"><a href="#一、问题由来" class="headerlink" title="一、问题由来"></a>一、问题由来</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> 把数组全部初始化为<span class="token number">0</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span> 把数组全部初始化为<span class="token number">1</span>，为什么却失败了呢？</code></pre><h2 id="二、数组的几种初始化方式"><a href="#二、数组的几种初始化方式" class="headerlink" title="二、数组的几种初始化方式"></a>二、数组的几种初始化方式</h2><p>1）完全初始化(completely initialized) 给每个元素初始化<br>int a[5]={0,1,2,3,4};<br>int a[]={1,2,3};</p><p>2）完全不初始化(uninitialized)<br>int a[5];<br>注意：<br>不进行显式初始化的情况下：</p><blockquote><ul><li><b>未初始化的</b>全局变量以及静态变量的初始均为0（因为他们都存在.bss段，默认初始化为0）</li><li><b>未初始化的</b>局部变量(自动变量)随机（其实也不叫随机，要是你能够精确的设计上一个释放这块内存的地方存了什么值）。（局部变量处于栈区，其数值是当时内存中的值。）</li></ul></blockquote><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:(不确定的)</span><span class="token comment" spellcheck="true">//6487736</span><span class="token comment" spellcheck="true">//4202350</span><span class="token comment" spellcheck="true">//4202256</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//29</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><p>3）不完全初始化(partly initialized)（即：部分初始化）<br>int a[5]={0,1,2};<br>K&amp;R C语言中是这样阐述：</p><blockquote><ul><li><b>如果初始化表达式的个数比数组元素数少，则对外部变量，静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0。</b>(至于为什么是初始化为0而不是其他的，原因是.bss的实现机制)</li><li>如果初始化表达式的个数比数组元素数多,则是错误的。<br>所以，上面数组，前三个元素被初始化为0，1，2，后两个元素被初始化为0。</li></ul></blockquote><p>实际上，int a[5]={0};属于不完全初始化，先把第一个元素初始化为0，由于初始化元素个数不够，所以剩余的元素按照规则被初始化为0，虽然都是0，但是它和后面那些0的意义不同（此0非彼0）</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//1</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> bb<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span> <span class="token punctuation">,</span>bb<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//output:</span><span class="token comment" spellcheck="true">//1</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span><span class="token comment" spellcheck="true">//0</span></code></pre><h2 id="三、初始化和赋值区别："><a href="#三、初始化和赋值区别：" class="headerlink" title="三、初始化和赋值区别："></a>三、初始化和赋值区别：</h2><p>只有在数组定义时，给数组值才叫初始化<br>定义过后，再给数组值叫赋值</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配之BF&amp;RK</title>
      <link href="/2020/06/01/BF-RK/"/>
      <url>/2020/06/01/BF-RK/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串匹配算法预告"><a href="#字符串匹配算法预告" class="headerlink" title="字符串匹配算法预告"></a><font face="楷体">字符串匹配算法预告</font></h1><blockquote><ul><li><font face="楷体" color=red size=5>单模式串匹配算法</font><blockquote><ul><li><b>BF算法</b>（Brute Force 的缩写，也叫暴力匹配算法，朴素匹配算法)<blockquote><ul><li>Brute adj. 蛮干不动脑筋的</li></ul></blockquote></li><li><b>RK算法</b>（Rabin-Karp 算法）<blockquote><ul><li>由它的两位发明者 Rabin 和 Karp 的名字来命名的</li></ul></blockquote></li><li><b>BM算法</b>（Boyer-Moore 算法）<blockquote><ul><li>它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的KMP 算法的3到4倍。</li></ul></blockquote></li><li><b>KMP算法</b></li></ul></blockquote></li><li><font face="楷体" color=red size=5>多模式串匹配算法</font><blockquote><ul><li><b>Trie树</b>，（又称前缀树，字典树，单词查找树）<blockquote><ul><li>Trie这个术语来自于retrieval根据词源学, trie的发明者Edward Fredkin把它读作/‘tri:/ “tree”。但是 ,其他作者把它读作/‘tra1/ “try”。</li></ul></blockquote></li><li><b>AC自动机算法</b>（Aho–Corasick算法）是由Alfred V.Aho和Margaret J.Corasick 发明的<blockquote><ul><li>其实，Trie树跟AC自动机之间的关系，就像单模式串匹配中朴素的串匹配算法，跟KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上罢了。</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><p><b>单模式串匹配的算法</b><br>也就是一个串和一个串进行匹配<br><b>多模式串匹配的算法</b><br>是在一个串中同时查找多个串</p><h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>一顿暴力，直接贴代码</p><p>//指针做输入，const修饰避免改动。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">BF</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>text <span class="token comment" spellcheck="true">/*in*/</span> <span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pattern <span class="token comment" spellcheck="true">/*in*/</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>text<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//非法输入</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> pos<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//位置 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token string">'\0'</span><span class="token operator">!=</span>text<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span>pos<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//text回溯 </span>        <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//pattern回溯 </span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//已经匹配字符长度</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token string">'\0'</span><span class="token operator">!=</span>pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token operator">++</span>sum<span class="token punctuation">;</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">==</span><span class="token function">strlen</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> pos<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">++</span>pos<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//匹配失败    </span><span class="token punctuation">}</span></code></pre><p>分析BF算法：</p><blockquote><ul><li>时间复杂度$O(n*m)$</li><li>空间复杂度$O(1)$</li></ul></blockquote><p>其他补充：</p><blockquote><ul><li>尽管理论上，BF算法的时间复杂度很高，但在实际的开发中，它却是一个比较常用的字符串匹配算法：<blockquote><ul><li>1.实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度大，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</li><li>2.BF算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug 也容易暴露和修复。<b>在工程中，在满足性能要求的前提下，简单是首选。</b>这也是我们常说的<b>KISS（Keep it Simple and Stupid）设计原则</b>。所以，在实际的软件开发中，绝大部分情况下，BF算法就够用了</li></ul></blockquote></li></ul></blockquote><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p><b>联系</b>：RK算法是BF算法的改进，它巧妙借助了我们前面讲过的哈希算法，引入<font face="楷体" color=red size=5>哈希算法</font>，时间复杂度立刻就会降低。<br><b>难点</b>：设计一个可以应对各种类型字符的哈希算法并不简单</p><p><b>思路</b>:我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（当然我们需要考虑哈希冲突的问题）。比较哈希值是非常快速的，所以效率提高了。<br>不过这又<b>引入一个问题</b>：通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率？<br><b>哈希算法设计技巧</b>：我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。</p><p><b>没有冲突的哈希</b>：我们只需要比较一下模式串和子串的哈希值<br><b>有冲突的哈希</b>：当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。解决方法很简单。当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只<br>需要再对比一下子串和模式串本身就好了。<br>当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。</p><p>总结：哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间<br>复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本<br>身，那时间复杂度就会退化成$O(n*m)$</p><p><b>但一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。</b></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的const底层机制</title>
      <link href="/2020/05/31/Cplusplus-const/"/>
      <url>/2020/05/31/Cplusplus-const/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中对C的const关键字增强"><a href="#C-中对C的const关键字增强" class="headerlink" title="C++中对C的const关键字增强"></a>C++中对C的const关键字增强</h1><h2 id="一、问题导入"><a href="#一、问题导入" class="headerlink" title="一、问题导入"></a>一、问题导入</h2><p>背景：<br>我们总说C语言中const修饰的变量看上去似乎是常量，其实是个“冒牌货”，应该叫”常变量”，比如用指针间接赋值，就能改变了。</p><p>代码测试：<br>将指针间接修改变量值的代码放到C语言编译器和C++编译器去测试</p><p>DevC++的C语言编译器</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//demo.c </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<br> <img src="/photos/2020.5.30_31/01.png" width="80%"></p><p>DevC++的C++语言编译器</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//test.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<br> <img src="/photos/2020.5.30_31/02.png" width="80%"></p><p>奇特的结果：<br>我们要是写了这样的函数在银行程序中，要是用不同编译器，那么对账就对不上了。<br>总结：<br>C中的const是个常变量，变量的值能够被间接修改。<br>C++中的const是一个真正的常量！</p><p>Tips：</p><table><td bgcolor=#FFFF FF>以上两次测试，都没有显示warning和error</td></table><p>那么，我们或许会疑惑：<br>Q：我们说C++中的是一个真正的常量，那为什么，没有C++编译器对我们”用指针间接修改”的行为，没有报warning或者error呢？<br>A：C++要兼容C，所以，它认为这个语法是可以的<br>Q：那么问题又来了，那他既然兼容，那么为什么最后却没改变那个变量的值呢？<br>A：因为C++只是兼容那种语法写法，但是底层的实现却对const关键字进行了加强。</p><h2 id="二、底层原理分析"><a href="#二、底层原理分析" class="headerlink" title="二、底层原理分析"></a>二、底层原理分析</h2><h3 id="1）C-编译器对const做了一些加强，做了一些特殊的处理"><a href="#1）C-编译器对const做了一些加强，做了一些特殊的处理" class="headerlink" title="1）C++编译器对const做了一些加强，做了一些特殊的处理"></a>1）C++编译器对const做了一些加强，做了一些特殊的处理</h3><p>当C++编译器，扫描到常量声明时，它不再像C语言那样，把这个const给它单独分配内存。</p><p>在我们先前的//test.cpp中。<br>C++进行了如下操作：</p><blockquote><ul><li>1）扫描到这一行，const int a=98;<br>C++编译器会把这个<b>变量a</b>放在一个<b>符号表（键值-值对）</b>里面<br><b>此时，并没有分配内存！！！</b><br>注意：这样的话，key和value是定了，不能修改的了。<br>符号表具体的实现和我们的内存中的，栈，堆不是同一套实现机制。<br>有很多常量就都放在这个里面了。<br>Tips：<br>当你去<b>使用</b>这个a的时候，它就给你从符号表里面给你把这个98给拿出来，供你<b>使用</b></li></ul></blockquote><table><td bgcolor=#FFFF FF>注意"使用"一词</td></table><blockquote><ul><li>2）遇到类似这样的情况，此时才给a变量另外分配一个内存。<br>扫描到这一句p=(int <em>)&a;<br>当你对这个a变量取地址的时候，C++编译器，会为这个a再<b>单独的开辟一块内存空间</b>，然后你把这个内存空间，赋给了p，相当于一个指针P指向了这里。然后你通过</em>p去间接的修改的地址，不再是原来的值（value）,而是我们新开辟的空间的值（注意理解）<br>所以，当你再使用a的时候，你打印的还是98（符号表中的a）<img src="/photos/2020.5.30_31/03.png" width="90%"></li></ul></blockquote><h3 id="2）证明"><a href="#2）证明" class="headerlink" title="2）证明"></a>2）证明</h3><p>我们现在来证明这个开辟的内存空间的存在</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//solution.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*p=%d"</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>打印的是:<br> <img src="/photos/2020.5.30_31/04.png" width="80%"></p><p><b>注意：</b></p><table><td bgcolor=#FFFF FF>C++编译器虽然可能为const常量分配空间，但不会<b>使用</b>其存储空间中的值，除非你用指针操作。</td></table><h2 id="三、结论和补充"><a href="#三、结论和补充" class="headerlink" title="三、结论和补充"></a>三、结论和补充</h2><p>1）C语言中的const变量<br>C语言中const变量是只读变量，<b>有自己的存储空间</b><br>2）C++中的const常量</p><table><td bgcolor=#FFFF FF>注意：可能分配存储空间,也可能不分配存储空间!</td></table><p>编译过程中若发现<b>使用常量</b>则直接以符号表中的值替换</p><p>Tips：<br>只有下面两种的时候，它才会分配空间</p><blockquote><ul><li>当const常量为全局，并且需要在其它文件中使用,即使用了<b>extern</b>操作符</b></li><li>当使用&amp;操作符取const常量的地址，编译过程中若发现对const使用了<b>&amp;操作符</b>，则给对应的常量分配存储空间（兼容C）</li></ul></blockquote><h2 id="四、补充疑问"><a href="#四、补充疑问" class="headerlink" title="四、补充疑问"></a>四、补充疑问</h2><p>Q：那么要是分配内存，C++中那个const的分配内存是在什么时候分配的呢？是在编译器<b>编译阶段</b>，还是在<b>执行阶段</b>分配？</p><table><td bgcolor=#FFFF FF>Ａ：C++中const分配内存的时机，是在编译期间！（记住！）</td></table><p>证明的代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//test.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a=%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;b=%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用了取地址 </span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;c=%d\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre> <img src="/photos/2020.5.30_31/05.png" width="80%"><p>结果表明：<br>const int b的地址在a和c之间，符合我们局部变量申请内存的<b>压栈的顺序</b>，<b>它并没有因为，&amp;b这句话写到int c后面，就先分配a，c最后才b</b>，而是，它扫描完之后，看到这里有&amp;b了，就分配地址了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性排序</title>
      <link href="/2020/05/30/Linear-Sort/"/>
      <url>/2020/05/30/Linear-Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="三种线性排序"><a href="#三种线性排序" class="headerlink" title="三种线性排序"></a>三种线性排序</h1><h2 id="一、前述"><a href="#一、前述" class="headerlink" title="一、前述"></a>一、前述</h2><p>《算法导论》中提到有定理表明：</p><blockquote><ul><li>任何比较排序在最坏的情况下都要经过$\Omega(nlogn)$次比较</li></ul></blockquote><p>下面讨论三种<b>线性时间复杂度</b>的排序算法。<br>原因：这三种算法是用<b>运算</b>而不是<b>比较</b>来确定排序顺序的，所以能够突破这个定理的桎梏</p><p>排序算法四问：</p><blockquote><ul><li><b>1)时间复杂度</b></li><li><b>2)空间复杂度</b></li><li><b>3)排序是否原地</b><blockquote><ul><li><b>原地排序</b>：指不需要开辟额外空间</li></ul></blockquote></li><li><b>4)稳定性</b><blockquote><ul><li><b>稳定的排序</b>：具有相同值的元素在输出数组中的相对次序与他们在输入数组中的相对次序<b>相同</b></li><li><b>意义</b>：只有当进行排序的数据还附带<b>“卫星数据”</b>时才比较重要。  eg.我们排序的是结构体的整数值，而整数值相同的，可能他的字符串不同。</li></ul></blockquote></li></ul></blockquote><h2 id="二、计数排序（counting-sort）读音是第4声"><a href="#二、计数排序（counting-sort）读音是第4声" class="headerlink" title="二、计数排序（counting sort）读音是第4声"></a>二、计数排序（counting sort）读音是第4声</h2><h3 id="1-假设和操作"><a href="#1-假设和操作" class="headerlink" title="1.假设和操作"></a>1.假设和操作</h3><h4 id="输入数据假设"><a href="#输入数据假设" class="headerlink" title="输入数据假设"></a>输入数据假设</h4><p>假设n个输入元素中的每个元素都是在[min,max]区间的一个<b>整数</b>。<br>排序快的原因：</p><blockquote><ul><li>进行了上面的假设</li><li>用空间换时间</li></ul></blockquote><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><blockquote><ul><li>1·建立一个长度为max-min+1的统计数组，元素初始化为0</li><li>2·每次扫描进数据，那么对应的统计数组的值+1（数组每一个下标位置的值，代表了数列中对应整数出现的次数）<b>（计数一词的来源）</b></li><li>3·遍历统计数组，输出数组元素的下标值，元素的值是几，就输出几次</li><li>4·如果排序的带有<b>“卫星数据”</b>,则需要进行第4步————此举，保证了计数排序的稳定性<blockquote><ul><li>对已经填充完的统计数组，做一下变形——具体的请见下面场景</li><li>根据情况，选择正向或者反向遍历统计数组</li></ul></blockquote></li></ul></blockquote><p>Tips：计数排序的稳定性很重要的另一个原因是：计数排序经常会被用作基数排序算法的一个子过程，为了使基数排序正确执行，计数排序必须是稳定的。</p><p>创造场景如下：</p><blockquote><ul><li>假设有一个企业的招聘系统规则如下<blockquote><ul><li>申请者需要投递简历，写好姓名，将得到一个原始的排名Ranking</li><li>为了激励大家投递简历，发布了一条通知,我们的排名（Ranking）依据两个维度来给申请者面试名额<blockquote><ul><li>1.笔试成绩高者，排名（Ranking）高</li><li>2.笔试成绩相同者，公司会给先投递简历的人高的排名（Ranking）<br>此处体现了，排序的稳定性需求</li><li>我们最后会将排名（Ranking）前4的申请者的名字（name）打印出来<br>名字是我们要排序的成绩（grade）的卫星数据</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><p>申请者的结构体设计如下</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Apply<span class="token punctuation">{</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> grade<span class="token punctuation">;</span><span class="token punctuation">}</span>Ranking<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>显然，我们的计数排序是根据结构体的元素，grade来排名。<br>此外，为了容易说明计数排序，我们假设，笔试成绩范围是0-10分<br>投递简历如下图：<br> <img src="/photos/2020.5.30_31/1.png" width="80%"><br> 笔试完了，成绩如下图：<br><img src="/photos/2020.5.30_31/2.png" width="80%"><br>请按照规则给上面排序，注意：小橙和小青的成绩都是6<br>操作：<br>1·建立一个长度为11的统计数组，元素初始化为0，表示我们的成绩为0-10<br>2·每次扫描进数据，那么对应的统计数组的值+1<br>显然获得统计数组如下图：<br><img src="/photos/2020.5.30_31/3.png" width="90%"><br>3.暂时，不需要输出<br>4.对统计数组进行变形：<br>方法，从倒数第2位开始，反向遍历统计数组，a[i]=a[i-1]+a[i];<br>相加的目的,是为了让统计数组存储的元素值,等于相应grade的排名的最终排序位置。<br><img src="/photos/2020.5.30_31/4.png" width="90%"><br>5.接下来,我们创建输出数组,长度和输入数组一致。<br>然后</p><table><td bgcolor=#FFFF FF>注意1）从后往前遍历</td></table>原先的输入数组小青，成绩6，查统计数组,值为2(有2个同成绩的)，查变形后数组，放输出数组<b>第5位</b>Tips：查到统计数组值为2，我们在放完小青到输出数组之后，需将变形后的数组的值减1，变成了4<table><td bgcolor=#FFFF FF>注意2）从5变成4,代表着下次再遇到6分的成绩时,最终排名是第4。(这就保证了计数排序的稳定性!)</td></table><p>小蓝，成绩7,查统计数组,值为1(唯一)，查变形后的数组，放输出数组的<b>第3位</b><br>小绿，成绩5,查统计数组,值为1(唯一)，查变形后的数组，放输出数组的<b>第6位</b><br>小黄，成绩8,查统计数组,值为1(唯一)，查变形后的数组，放输出数组的<b>第2位</b></p><p>小橙，成绩6,查统计数组,值为2(有2个同成绩的)，查变形后数组，知放输出数组<b>第4位</b><br>我们在放完小橙到输出数组之后，需将变形后的数组的值，减1，变成了3</p><p>小红,成绩9,查统计数组,值为1(唯一)，查变形后的数组，知放输出数组的<b>第1位</b> </p><p>排序后结果（如图，保证了卫星数据的稳定性）：<br><img src="/photos/2020.5.30_31/5.png" width="90%"></p><h3 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2.算法分析"></a>2.算法分析</h3><blockquote><ul><li>时间复杂度：$O(n+m)$    其中m是原始数组的整数范围</li><li>空间复杂度：$O(n+m)$</li><li>是否原地排序：否</li><li>稳定性：稳定</li><li>数据结构：数组，hash</li></ul></blockquote><p>Tips：有人也把统计数组的每个位置，叫做一个个桶，但我们暂时不这么叫，免得大家将桶排序和计数排序弄混了</p><h3 id="3-局限性"><a href="#3-局限性" class="headerlink" title="3.局限性"></a>3.局限性</h3><blockquote><ul><li>1.当输入数组元素最大最小值差距过大时<br>比如给定20个随机整数,范围在0到1亿之间,这时若使用计数排序,需创建长度为1亿的数组。严重浪费空间,且时间复杂度也随之升高。<br>解决方案：见桶排序</li><li>2.当输入数组元索不是整数，如字符，浮点数<blockquote><ul><li>如果数列中的元素都是小数,比如25.23 ,或是0.01这样子,无法创建对应的统计数组。<br>解决方案1：假如是0.3,0.13,0.001,0.22  我们可以将他们全乘1000，然后就转换为计数排序，输出的时候，记得除回来<br>解决方案2：见桶排序</li><li>如果数列中的元素都是字符或字符串,比如abc,b,c<br>解决方案1：借助字符的ASCII码，按位赋权，转换hash为数字，再排序<br>解决方案2：见基数排序，借助字符的ASCII码。</li></ul></blockquote></li><li>4.如果，输入的元素是大整数，比如15位长的号码1234567894554541,可是,15位长的号码有多少种组合?这要建立一个大得不可想象的数组,才能装下所有可能出现的15位长的号码，很不划算!<br>解决方案：见基数排序（思想：减而治之）</li><li>5.其他————碰到了再补充，总之，要灵活运用，而不是将某种算法运用场景当做教条，场景只是帮助更好的理解算法的一种方式。</li></ul></blockquote><h2 id="三、基数排序（Radix-sort）读音是第1声"><a href="#三、基数排序（Radix-sort）读音是第1声" class="headerlink" title="三、基数排序（Radix sort）读音是第1声"></a>三、基数排序（Radix sort）读音是第1声</h2><h3 id="1-操作"><a href="#1-操作" class="headerlink" title="1.操作"></a>1.操作</h3><p>需求：为如下一组英文单词排序<br><img src="/photos/2020.5.30_31/6.png" width="90%"><br>操作：我们把排序工作拆分成多个阶段,每一个阶段只根据一个字符(基数排序，基字的由来)进行计数排序, 一共排序k轮, k是元素长度。<br>如何将这些字符串按照字母顺序排序呢?<br>具体的<br>由于每个字符串的长度是3个字符,我们可以把排序工作拆分成3轮</p><blockquote><ul><li>第一轮:按照最低位字符排序。排序过程使用计数排序,把字母的ascii码对应到数组下标，第1轮排序结果如下:<img src="/photos/2020.5.30_31/7.png" width="90%"></li></ul></blockquote><blockquote><ul><li>第二轮:<b>在第一轮排序结果的基础上</b>,按照第二位字符排序，第2轮排序结果如下:<img src="/photos/2020.5.30_31/8.png" width="90%"></li></ul></blockquote><table><td bgcolor=#FFFF FF>注意：这里使用的计数排序必须是稳定排序,这样才能保证第1轮排出的先后顺序在第2轮还能继续保持！</td></table><table><td bgcolor=#FFFF FF>比如，在第1轮排序后,元素uue在元素yui之前。那么第二轮排序时,两者的第二位字符虽然同样是u,但先后顺序一定不能变,否则第1轮排序就白做了。</td></table><blockquote><ul><li>第三轮：同理，略。</li></ul></blockquote><blockquote><ul><li>基数排序(Radix Sort)：形如这样把字符串元素按位拆分,每一个基位进行一次稳定性的排序的算法,就是基数排序<br>基数排序既可以<b>从高位优先</b>进行排序（Most Significant Digit first ,简称MSD ）<br>也可以<b>从低位优先</b>进行排序（Least Significant Digit first ,简称LSD）<br>刚才我们所举的例子,就是典型的LSD方式的基数排序。</li></ul></blockquote><h3 id="2-疑问"><a href="#2-疑问" class="headerlink" title="2.疑问"></a>2.疑问</h3><p>问：如果排序的字符串长度不规则呢?  比如有的字符串是5位，有的是3位</p><pre><code>bananaappleorangeapehe</code></pre><p>毛主席说过，<b>没有条件，我们就创造条件</b><br>创造条件：<br>我们以最长的字符串为准，其他长度不足的字符串，在<b>末尾补0</b>即可</p><pre><code>bananaapple0orangeape000he0000</code></pre><p>在排序时,我们把字符0当做是比a更小的字符,排序结果如下:</p><pre><code>ape000apple0bananahe0000orange</code></pre><h3 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="3.算法分析"></a>3.算法分析</h3><blockquote><ul><li>时间复杂度：$O(k(n+m))$    其中m是原始数组的整数范围<br>由于字符串元素的长度k是一个固定常量，所以我们认为这个是一个线性的排序算法。</li><li>空间复杂度：$O(n+m)$    至于空间复杂度，由于基数排序的辅助数组是反复重用的，所以基数排序的空间复杂度和计算排序一样。</li><li>是否原地排序：否</li><li>稳定性：稳定</li><li>数据结构：数组，hash</li></ul></blockquote><table><td bgcolor=#FFFF FF>注意点：</td></table><table><td bgcolor=#FFFF FF>1.上面的算法时间复杂度分析是不够完善的，其实上面的是以计数排序这种稳定排序作为基数排序的子过程的复杂度分析。基数排序，其实主要是强调，我们对待一些排序，可以按位（比如，我们二进制中，按照以2为基的任何位），来分别排序。</td></table><table><td bgcolor=#FFFF FF>2.推而广之：基数排序的子过程，可以是任何具有稳定性的排序算法（注意点）eg.插入排序，折半插入排序，冒泡排序</td></table><table><td bgcolor=#FFFF FF>Tips:其实，基数排序的算法的时间复杂度分析依赖于我们所使用的稳定的排序算法！！！</td></table><h2 id="四、桶排序（bucket-sort）"><a href="#四、桶排序（bucket-sort）" class="headerlink" title="四、桶排序（bucket sort）"></a>四、桶排序（bucket sort）</h2><h3 id="1-假设和操作："><a href="#1-假设和操作：" class="headerlink" title="1.假设和操作："></a>1.假设和操作：</h3><blockquote><ul><li>碎碎念：桶排序同样是一种线性时间的排序算法。类似于计数排序所创建的<b>统计数组</b>，桶排序需要创建<b>若干个桶</b>来协助排序。这也大概是为什么有的人，将计数排序中的统计数组的叫做一个个桶的原因吧，然后推而广之，也在基数排序中叫桶<br>殊不知：有时就是这样的叫法把初学者弄混了，不知道，是不是有桶的都叫桶排序？</li></ul></blockquote><p>其实，《算法导论》一书中，并没有把计数排序和基数排序中的统计数组叫桶…</p><p>但是，其实桶排序体现的是一种思想，我们不用纠结的是”桶”到底是什么，我们需要的是根据实际情况去选择合适的数据结构去存储，实现这个抽象的”桶”，所以，我们也将计数和基数排序中的统计数组算做是”桶”点一种实现方式吧。</p><p>与计数排序相似，因为对输入数据进行了某种假设，桶排序的速度也很快。<br>假设：输入数据服从<b>均匀分布</b></p><p>那么,桶排序当中所谓的”桶”，又是什么概念呢?<br>每一个桶(bucket)代表一个区间范围,里面可以承载一个或多个元素。</p><blockquote><ul><li>操作：<blockquote><ul><li>第一步，就是创建这些桶,确定每一个桶的区间范围</li><li>第二步，将创建这些桶,分别都进行排序处理（由于，数据满足均匀分布，所以，我们的每个桶放的元素应该都差不多一样多，也就是均匀）</li><li>第三步，合并桶，进行输出</li></ul></blockquote></li></ul></blockquote><h3 id="2-算法分析-1"><a href="#2-算法分析-1" class="headerlink" title="2.算法分析"></a>2.算法分析</h3><p>假设原始数列有n个元素,分成m个桶, 平均每个桶的元素个数为n/m。<br>下面我们来逐步分析算法复杂度:<br>第一步，求数列最大最小值,运算量为n。<br>第二步，创建空桶,运算量为m。<br>第三步，遍历原始数列,运算量为n。<br>第四步，在每个桶内部做排序,若是使用了$0(nlogn)$的排序算法,所以运算量为<br>$n/m * log(n/m)* m$<br>第五步,输出排序数列,运算量为n。<br>加起来,总的运算为$3n+m+ n/m * log(n/m)* m = 3n+m+ n(logn-logm)$<br>去掉系数,时间复杂度为:<br>$O(n+m+n(logn-logm))$</p><p>空间复杂度:<br>空桶占用的空间+数列在桶中占用的空间=$O(n+m)$</p><blockquote><ul><li>时间复杂度：$O(n+m+n(logn-logm))$</li><li>空间复杂度：$O(n+m)$    </li><li>是否原地排序：否</li><li>稳定性：若是桶内使用不稳定的排序，则不稳定，但是桶与桶之间是稳定的</li><li>数据结构：数组，链表，堆…看场景</li></ul></blockquote><table><td bgcolor=#FFFF FF>Tips：分析</td></table><blockquote><ul><li>时间复杂度：<blockquote><ul><li>最坏n方（一个桶)）</li><li>最好为n（n个桶而且值排列均匀）</li></ul></blockquote></li><li>空间复杂度：<blockquote><ul><li>其实，要是想要空间复杂度最好，得用链表，但是那样时间复杂度就做不到最好</li></ul></blockquote></li></ul></blockquote><h2 id="五、联系和总结"><a href="#五、联系和总结" class="headerlink" title="五、联系和总结"></a>五、联系和总结</h2><p>总的来说，计数排序，基数排序，桶排序都是用的空间换取时间的思想。<br>另外，我们的计数排序和基数排序都可以看做是桶排序，”桶思想”的一种特例。</p><blockquote><ul><li>由于，桶排序的复杂度分析很依赖于具体的数据，我们常用的反而是计数排序和基数排序。</li><li>从桶排序的算法分析中，我们需要知道的是，没有绝对高效的算法，只有合适的算法应用场景！！！</li><li>总的说来，算法的设计，一般体现的是用时间换空间，或者空间换时间。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言和C++变量的命名规则</title>
      <link href="/2020/05/29/The-Rules-Of-Variable-Name/"/>
      <url>/2020/05/29/The-Rules-Of-Variable-Name/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言和C-变量命名规则探讨"><a href="#C语言和C-变量命名规则探讨" class="headerlink" title="C语言和C++变量命名规则探讨"></a>C语言和C++变量命名规则探讨</h1> <img src="/photos/2020.5.29/title_one.jpg" width="80%"><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><blockquote><ul><li>不能是C语言或者C++的标识符。</li><li>区分大小写</li><li>变量的第1个字符必须是大小写字母或者下划线。</li><li>即，除去第1个字符之外的其他字符是大小写字母，下划线，或数字。 </li></ul></blockquote><p><strong>疑问</strong>：为什么，第3点要求看上去这么奇怪？<br>为什么，不直接说，是直接由大小写字母，下划线，数字组成就好了，为何要强调第1个字符，不能是数字？<br>看上去，一点都不对称，没有美感</p><p><strong>解释</strong>:<br>想象一下，定义这样一个变量<br>int 1=9;//变量名字，要是叫1，那么我们的程序，难道以后，我用1就是9？多尴尬</p><p>反观<br>char c=’d’;<br>char D=’c’;<br>这样的多好，原因是：<br>字符在C语言和C++中是有单引号’’围着的<br>字符串是有双引号””围着的</p><p>或许，创造者在变量名取名规则的时候，首先是考虑了<br>1)大小写字母，毕竟是人家母语，要是计算机语言和母语由类似之处，多好。<br>2)数字，毕竟，阿拉伯数字享誉全球。<br>3)下划线，ummm，或许是为了今后的下划线命名法？？？疑问。。</p><p>然后发现，前面那样int 1=9;这样奇怪的语句，就规则强化了</p><h2 id="工程上主流的变量命名法"><a href="#工程上主流的变量命名法" class="headerlink" title="工程上主流的变量命名法"></a>工程上主流的变量命名法</h2><ul><li>下划线命名法（C语言软件设计师常用）</li><li>驼峰命名法（Java软件设计师常用）</li><li>帕斯卡命名法</li><li>匈牙利名</li></ul><table><tr><td bgcolor=#FFFF FF>（——————未完待续）</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 奇怪的想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大端和小端存储</title>
      <link href="/2020/05/29/Big-Endian-little-Endian/"/>
      <url>/2020/05/29/Big-Endian-little-Endian/</url>
      
        <content type="html"><![CDATA[<h2 id="引子："><a href="#引子：" class="headerlink" title="引子："></a><strong>引子</strong>：</h2><p>《格列夫游记》一书中讲到，格列佛在小人国中，遇到了这样一件事情：</p><blockquote><p> 小人国的人纠结于吃鸡蛋的时候，先打破鸡蛋的小端还大端，原来，在这之前所有人都认为,吃鸡蛋前,原始的方法是打破鸡蛋较大的一端。可是当今皇帝的祖父小时候吃鸡蛋,一次按古法打鸡蛋时碰巧将一个手指弄破了,因此他的父亲,当时的皇帝，就下了一道敕令,命令全体臣民吃鸡蛋时打破鸡蛋较小的一端,违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱,其中一个皇帝送了命,另一个丢了王位。关于这一争端,曾出版过几百本大部著作,不过大端派的书一直是受禁的,法律也规定该派的任何人不得做官。</p></blockquote><p>在计算机界，也有一个类似的大端小端之争，但是并没有像小人国那般，原先我们虽然在纠结选大端还是小端存储？但是随着计算机的发展，历史告诉我们，这些都是合理的，但是要在计算机间合理通信或者理解计算机底层的时候，你自己记得转换就好了。</p><h1 id="大端和小端存储"><a href="#大端和小端存储" class="headerlink" title="大端和小端存储"></a>大端和小端存储</h1><h2 id="一．概念"><a href="#一．概念" class="headerlink" title="一．概念"></a>一．概念</h2><p>大端：指低字节存储在高地址。<br>小端：指低字节存储在低地址。</p><p><strong>记忆方法：</strong></p><table><td bgcolor=#FFFF FF>小端说：我就是个低低（弟弟）</td></table><p>下图描述了——大端存储（低字节存储在内存高地址了）：<br> <img src="/photos/2020.5.29/1.png" width="80%"></p><p>下图描述了——小端存储（低字节存储在内存低地址了）：：<br> <img src="/photos/2020.5.29/2.png" width="80%"></p><h2 id="二．具体的，大端法和小端法的应用"><a href="#二．具体的，大端法和小端法的应用" class="headerlink" title="二．具体的，大端法和小端法的应用"></a>二．具体的，大端法和小端法的应用</h2><p>有的产品用的大端法，有的产品则是小端法。<br>PS:这个大端和小端并没有严格按照企业界限来区分，因为有的企业，它在之前采用的处理器，可能是大端，但是后面的产品中改变了采用的处理器，可能就采用小端法了。<br>前沿：许多比较新的微处理器使用双端法，也就是说可以把它们配置成作为大端或者小端的机器运行。</p><h2 id="三．大端法和小端法导致的问题："><a href="#三．大端法和小端法导致的问题：" class="headerlink" title="三．大端法和小端法导致的问题："></a>三．大端法和小端法导致的问题：</h2><h3 id="1）网络应用程序数据传输"><a href="#1）网络应用程序数据传输" class="headerlink" title="1）网络应用程序数据传输"></a>1）网络应用程序数据传输</h3><p>在采用不同大小端存储的机器之间通过网络传送二进制数据时候，会导致采用不同大小端存储方式的数据的字节变成反序。<br>解决方案：网络应用程序的代码编写，必须遵循已建立的关于字节顺序的规则（第一处：网络传输规定了，网络字节序(它采用的大端)）。<br>第2处，你的机器发送报文前，需要将你的内部表达转换成网络标准。<br>第3处，你的机器接受报文时候，需要根据你的机器，将网络标准转换为你的内部表示。。</p><p>网络字节序<br>网络上传输的数据都是字节流,对于一个多字节数值，在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;<br>UDP/TCP/IP协议规定:<br>把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;</p><p>而在发送端发送数据时，发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);<br>由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;所以说,网络字节序是大端字节序;</p><p>比如,我们经过网络发送整型数值0x12345678时,在80x86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数将其转换成大端法存放的数值;</p><p>常见CPU的宇节序<br>大端（big Endian）: PowerPC、IBM、 Sun<br>小端（little Endian）:x86、DEC<br>ARM既可以工作在大端模式,也可以工作在小端模式。</p><h3 id="2）反汇编的时候"><a href="#2）反汇编的时候" class="headerlink" title="2）反汇编的时候"></a>2）反汇编的时候</h3><table><tr><td bgcolor=#FFFF FF>（——————未完待续）</td></tr></table><h2 id="四．如何判别大端和小端"><a href="#四．如何判别大端和小端" class="headerlink" title="四．如何判别大端和小端"></a>四．如何判别大端和小端</h2><p>1）我们可以根据C语言中的，联合体来判断，该系统是大端还是小端。<br>因为，联合体变量总是从低地址存储。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">union</span> test    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">;</span>        <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>demo<span class="token punctuation">;</span>    demo<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">0x01ffff03</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x03</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这个机器是小端存储！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这个机器是大端存储！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"无法判断机器类型！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>显然，<br>要是小端存储，那么（低字节）0x03在低地址，<br>要是大端存储，那么（高字节）0x00在低地址。<br>所以，打印出3就是小端存储。打印出0那就是大端存储。<br>笔者的电脑是采用的intel的X86CPU，是小端存储。<br>  <img src="/photos/2020.5.29/3.png" width="80%"></p>]]></content>
      
      
      <categories>
          
          <category> 编译器底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言优先级和结合性记忆</title>
      <link href="/2020/05/28/test/"/>
      <url>/2020/05/28/test/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言优先级和结合性记忆"><a href="#C语言优先级和结合性记忆" class="headerlink" title="C语言优先级和结合性记忆"></a>C语言优先级和结合性记忆</h1><p><strong>前述</strong>：以前以为，记忆C语言的优先级和结合性就像孔乙己记忆“回”字的四种写法一样有些没必要，对于技术，简洁即美。但以下场景，记忆C语言的优先级结合性还是有一定好处<br><strong>场景</strong>：</p><blockquote><ul><li>记忆一些特定的优先级和结合性，能够帮助从编译器角度来快速识别多级指针和数组指针和函数指针判定指针类型。</li><li>某些项目的遗留代码中有一些编程风格不好的片段，总是不写括号，遇到就需要查书，对研究别人代码，有一定影响。记忆优先级和结合性，能够降低开发中重构已有代码的难度。</li><li>有的相关试题中，有考优先级的题目的存在。(考优先级不是目的，而是为了解决那些风格不好的遗留代码)</li><li>由于编译器语法分析阶段的设计原理，其他语言的优先级也可以在此基础上记忆。<blockquote><ul><li>C语言的优先级，再添加上一些C++本身的运算符，则很容易转换到记忆C++的优先级</li><li>Java的运算符的优先级和C语言相似</li></ul></blockquote></li></ul></blockquote><p><strong><center>优先级从高到低，分为15级</center></strong><br><img src="/photos/2020.5.28/2020_5.28_1.jpg" width="80%"><br><img src="/photos/2020.5.28/2020_5.28_2.jpg" width="80%"></p><h2 id="优先级记忆"><a href="#优先级记忆" class="headerlink" title="优先级记忆"></a>优先级记忆</h2><table><td bgcolor=#FFFF FF>初-单-算-移-关        （出箪蒜一罐）</td></table>  <table><td bgcolor=#FFFF FF>位-逻-三-赋-逗        （味落三伏豆）</td></table> <p>//箪—意指古代盛饭用的圆形竹器</p><blockquote><p>记忆场景：<br>每年三伏天农作时期，要为田间劳作者送饭，送饭者专门用箪盛着食物前往，还专门为其中一个很喜欢吃大蒜的劳作者带了一罐蒜解馋。后来，劳作者吃着发现，今年的三伏天的黄豆也格外美味。</p></blockquote><p>解释：<br>初：初级运算符<br>单：单目运算符<br>算：算数运算符（包含2个优先级）<br>移：移位运算符<br>关：关系运算符（包含2个优先级）</p><p>位：位运算（除去，位运算中的单目运算符~ 包含3个优先级）<br>逻：逻辑运算符（包含2个优先级）<br>三：三目运算符<br>赋：赋值运算符<br>逗：逗号运算符</p><h2 id="结合性记忆"><a href="#结合性记忆" class="headerlink" title="结合性记忆"></a>结合性记忆</h2><table><td bgcolor=#FFFF FF>单三赋    从右左</td></table> <p>除以上规则以外,还有一点。<br>标准的C语言编译器对运算符的解析遵循“最大贪婪”规则。</p><h2 id="“最大贪婪”规则"><a href="#“最大贪婪”规则" class="headerlink" title="“最大贪婪”规则"></a><strong>“最大贪婪”规则</strong></h2><p>当C语言编译器对源程序进行词法分析时，如果运算符的下一个符号还是运算符，并且能和前一个运算符构成一个新的合法运算符时，编译器的词法分析器必须将其解析为两个运算符符号构成的新的运算符。</p><p>举一个没太大实际意义的例子来辅证，例如: x=z+++y;<br>是按照x=z+(++y);来计算，还是按照x=(z++)+y;来计算呢?<br>根据C编译器的“最大贪婪”规则,是按照x=(z++)+y;来计算，而不是按照x=z+(++y)来计算<br>可以验证</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> z<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>x<span class="token operator">=</span>z<span class="token operator">++</span><span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出结果为8，而不是9</span><span class="token comment" spellcheck="true">//考点：C编译器的“最大贪婪”规则</span></code></pre><h2 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h2><ul><li><p>记忆第一优先级中的和第二优先级</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个数组指针，指向的类型是int (*)[3]</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个指针数组，里面的是int *类型的指针</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个二级指针，指向的类型是int *</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这是一个函数指针，指向的类型是int (*)(int,int)</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个返回值为指针的函数</span></code></pre></li><li><p>比格基地笔试题</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//以下程序的k最终值是：</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>k <span class="token operator">*</span><span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//答:90</span><span class="token comment" spellcheck="true">//解释  =是赋值运算符 *=是赋值运算符  +是算数运算符 </span><span class="token comment" spellcheck="true">//“出箪蒜一罐,味落三伏豆”知，算数运算符优先级高，先算i+j</span><span class="token comment" spellcheck="true">//考点：编程语言的优先级</span></code></pre></li><li><p>360公司笔试题</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> m<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>  <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token operator">=</span><span class="token operator">&amp;</span>m<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//“出箪蒜一罐,味落三伏豆”知,关系运算符==的优先级比赋值运算符=高，知i=0</span>  i<span class="token operator">=</span>p<span class="token operator">==</span><span class="token operator">&amp;</span>m<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//(-*p)中，-和*都是单目运算符，结合性是“单三赋，从右左”，所以，相当于(-n)</span>  j<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%d,j=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出为 i=0,j=7</span><span class="token comment" spellcheck="true">//考点：编程语言的优先级,结合性</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 记忆法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数暴力到欧拉筛法</title>
      <link href="/2020/05/28/hello-world/"/>
      <url>/2020/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="素数相关算法详解"><a href="#素数相关算法详解" class="headerlink" title="素数相关算法详解"></a>素数相关算法详解</h1><p>本文讲解了<strong>素数</strong> 的定义<br>并且从素数的暴力算法一路优化到了欧拉筛法</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><blockquote><ul><li>1.<a href="#jump010">素数的定义</a></li><li>2.<strong>素数相关算法</strong><blockquote><ul><li><a href="#jump021">判别素数的朴素法（暴力法）</a><blockquote><ul><li>算法原理</li><li>实现(轻微优化)</li></ul></blockquote></li><li><a href="#jump022">埃塞托尼亚筛</a><blockquote><ul><li>算法原理</li><li>实现1</li><li>实现2：对实现1的优化</li></ul></blockquote></li><li><a href="#jump023">欧拉筛</a><blockquote><ul><li>算法原理</li><li>实现 </li></ul></blockquote></li></ul></blockquote></li><li>3.==总结==</li></ul></blockquote><h2 id="1-素数的定义"><a href="#1-素数的定义" class="headerlink" title="1.素数的定义"></a>1.素数的定义</h2><p>维基百科定义：<br><strong>质数</strong>（Prime number），又称<strong>素数</strong><br><strong>指在大于1的自然数中</strong>，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。大于1的自然数若不是素数，则称之为<strong>合数</strong>（也称为<strong>合成数</strong>）。<br> <strong>Tips：</strong><br>1.有的教材上：（指在大于1的自然数中）这一点没有强调，导致容易误解！！！<br>也是经常弄晕一些人对素数的理解的原因。<br>2.所以：<table><tr><td bgcolor=#FFFF FF>1既不是素数也不是合数！！！</td></tr></table></p><h2 id="2-素数相关算法"><a href="#2-素数相关算法" class="headerlink" title="2.素数相关算法"></a>2.素数相关算法</h2><h3 id="判别素数的朴素法（暴力法）"><a href="#判别素数的朴素法（暴力法）" class="headerlink" title="判别素数的朴素法（暴力法）"></a>判别素数的朴素法（暴力法）</h3><span id="jump021"></span><h5 id="1）算法原理："><a href="#1）算法原理：" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>不管三七二十一<br>根据素数定义就是一顿暴力。</p><h5 id="2）实现-轻微优化"><a href="#2）实现-轻微优化" class="headerlink" title="2）实现(轻微优化)"></a>2）实现(轻微优化)</h5><h6 id="代码段："><a href="#代码段：" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//0表示不是素数，1表示是素数 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//表示根号n向下取整 </span>    <span class="token keyword">int</span> sqrt_num<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>sqrt_num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是素数 </span><span class="token punctuation">}</span></code></pre><h3 id="埃塞托尼亚筛"><a href="#埃塞托尼亚筛" class="headerlink" title="埃塞托尼亚筛"></a>埃塞托尼亚筛</h3><span id="jump022"></span><h5 id="1）算法原理：-1"><a href="#1）算法原理：-1" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>1&gt;假设从2-N全是素数<br>2&gt;从2开始枚举，对于每个素数，我们筛去它的所有倍数，最后我们剩下来的就都是素数<br><strong>关键点</strong>：<br>从2开始枚举到某个数字A，如果a没有被前面步骤的数筛去，那么a一定是素数。<br>原因：<br><strong>如果A(A&gt;2)是合数</strong>，则<strong>A=素数×另一个数</strong><br><strong>PS：这个素数必定小于A，所以会被我们前面筛出来的素数筛掉</strong></p><h5 id="2）实现"><a href="#2）实现" class="headerlink" title="2）实现"></a>2）实现</h5><p>用一个标记数组实现<br>枚举的过程中，筛的过程就是依次改变这个标记数组的过程</p><h5 id="实现1：按照思路直接筛，筛的过程如下图红色箭头所示"><a href="#实现1：按照思路直接筛，筛的过程如下图红色箭头所示" class="headerlink" title="实现1：按照思路直接筛，筛的过程如下图红色箭头所示"></a>实现1：按照思路直接筛，筛的过程如下图红色箭头所示</h5><img src="/photos/2020.5.28/2020_5.26_1.png" width="80%"><h6 id="代码段：-1"><a href="#代码段：-1" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Eratosthenes_one.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数i，并且Num+1</span>            <span class="token comment" spellcheck="true">//注意这种写法，本来应该用i*j&lt;=(maxn-1)判断就好了</span>            <span class="token comment" spellcheck="true">//但是要避免i*j的结果溢出int,所以改为j&lt;=((maxn-1)/i)</span>            <span class="token comment" spellcheck="true">//maxn-1是因为标记数组范围本来就只有0-100004 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                TagArray<span class="token punctuation">[</span>j<span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//筛去素数i的倍数 </span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+4中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="实现2："><a href="#实现2：" class="headerlink" title="实现2："></a>实现2：</h5><p>在实现1的基础上，我们发现，如图中蓝色部分的，被重复筛了。我们容易观察出，如果要减少筛的次数，我们可以从质数的平方往后筛（优化）<br><img src="/photos/2020.5.28/2020_5.26_2.png" width="80%"></p><h6 id="代码段：-2"><a href="#代码段：-2" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Eratosthenes_two.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数i，并且Num+1</span>            <span class="token comment" spellcheck="true">//注意这种写法，本来应该用i*j&lt;=(maxn-1)判断就好了</span>            <span class="token comment" spellcheck="true">//但是要避免i*j的结果溢出int,所以改为j&lt;=((maxn-1)/i)</span>            <span class="token comment" spellcheck="true">//maxn-1是因为标记数组范围本来就只有0-100004 </span>            <span class="token comment" spellcheck="true">//(修改处)将j=2改为了j=i，这样就能少筛掉表格中那些蓝色部分了 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                TagArray<span class="token punctuation">[</span>j<span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//筛去素数i的倍数 </span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+4中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><span id="jump023"></span><p><strong>由来</strong>：<br>由于埃塞托尼亚筛筛的时候重复筛（比如下面的）了，使得算法效率还不够好，所以，我们改进一下，我们继续观察先前的图，发现埃塞托尼亚筛是<strong>竖着筛</strong>，我们似乎也难以优化这种筛法了，我们转换一下思路——<strong>横着筛</strong></p><h5 id="1）算法原理：-2"><a href="#1）算法原理：-2" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>思路：在埃氏筛的一种优化<br>任何合数都能写成一个素数乘一个数（显然这个素数不一定是唯一的）<br>//举个例子：12=2<em>6=3</em>4（2和3都是素数）<br>所以，任何合数都有一个<strong>最小的质因数</strong></p><table><tr><td bgcolor=#FFFF FF>用这个"最小质因数"来判断什么时候不用继续筛下去</td></tr></table><p>那么如何实现呢？<br>欧拉研究发现，我要是<strong>横着筛</strong>就会比前面那种只优化掉蓝色部分的埃氏筛还快</p><img src="/photos/2020.5.28/2020_5.26_3.png" width="80%"><p><strong>注意</strong>：这里是横着筛，此外图中箭头从<strong>橙色出发（包括该点）</strong>往右的所有我都不筛<br>具体实现方法是用的一个<strong>break</strong>实现的。</p><h5 id="2）实现-1"><a href="#2）实现-1" class="headerlink" title="2）实现"></a>2）实现</h5><h6 id="代码段：-3"><a href="#代码段：-3" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Euler.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数，并且Num+1    </span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>Num<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//一进来,不管三七二十一，先筛掉一个先</span>            TagArray<span class="token punctuation">[</span>i<span class="token operator">*</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//判别i是Prime数组中某个的倍数，则跳出，</span>                <span class="token comment" spellcheck="true">//这行后面的也不用筛     </span>                <span class="token keyword">break</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>              <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+5-1中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
