<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言和C++变量的命名规则</title>
      <link href="/2020/05/29/The-Rules-Of-Variable-Name/"/>
      <url>/2020/05/29/The-Rules-Of-Variable-Name/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言和C-变量命名规则探讨"><a href="#C语言和C-变量命名规则探讨" class="headerlink" title="C语言和C++变量命名规则探讨"></a>C语言和C++变量命名规则探讨</h1> <img src="/photos/2020.5.29/title_one.jpg" width="80%"><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><blockquote><ul><li>不能是C语言或者C++的标识符。</li><li>区分大小写</li><li>变量的第1个字符必须是大小写字母或者下划线。</li><li>即，除去第1个字符之外的其他字符是大小写字母，下划线，或数字。 </li></ul></blockquote><p><strong>疑问</strong>：为什么，第3点要求看上去这么奇怪？<br>为什么，不直接说，是直接由大小写字母，下划线，数字组成就好了，为何要强调第1个字符，不能是数字？<br>看上去，一点都不对称，没有美感</p><p><strong>解释</strong>:<br>想象一下，定义这样一个变量<br>int 1=9;//变量名字，要是叫1，那么我们的程序，难道以后，我用1就是9？多尴尬</p><p>反观<br>char c=’d’;<br>char D=’c’;<br>这样的多好，原因是：<br>字符在C语言和C++中是有单引号’’围着的<br>字符串是有双引号””围着的</p><p>或许，创造者在变量名取名规则的时候，首先是考虑了<br>1)大小写字母，毕竟是人家母语，要是计算机语言和母语由类似之处，多好。<br>2)数字，毕竟，阿拉伯数字享誉全球。<br>3)下划线，ummm，或许是为了今后的下划线命名法？？？疑问。。</p><p>然后发现，前面那样int 1=9;这样奇怪的语句，就规则强化了</p><h2 id="工程上主流的变量命名法"><a href="#工程上主流的变量命名法" class="headerlink" title="工程上主流的变量命名法"></a>工程上主流的变量命名法</h2><ul><li>下划线命名法（C语言软件设计师常用）</li><li>驼峰命名法（Java软件设计师常用）</li><li>帕斯卡命名法</li><li>匈牙利名</li></ul><table><tr><td bgcolor=#FFFF FF>（——————未完待续）</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> C语言碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言碎碎念 </tag>
            
            <tag> 奇怪的想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大端和小端存储</title>
      <link href="/2020/05/29/Big-Endian-little-Endian/"/>
      <url>/2020/05/29/Big-Endian-little-Endian/</url>
      
        <content type="html"><![CDATA[<h2 id="引子："><a href="#引子：" class="headerlink" title="引子："></a><strong>引子</strong>：</h2><p>《格列夫游记》一书中讲到，格列佛在小人国中，遇到了这样一件事情：</p><blockquote><p> 小人国的人纠结于吃鸡蛋的时候，先打破鸡蛋的小端还大端，原来，在这之前所有人都认为,吃鸡蛋前,原始的方法是打破鸡蛋较大的一端。可是当今皇帝的祖父小时候吃鸡蛋,一次按古法打鸡蛋时碰巧将一个手指弄破了,因此他的父亲,当时的皇帝，就下了一道敕令,命令全体臣民吃鸡蛋时打破鸡蛋较小的一端,违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱,其中一个皇帝送了命,另一个丢了王位。关于这一争端,曾出版过几百本大部著作,不过大端派的书一直是受禁的,法律也规定该派的任何人不得做官。</p></blockquote><p>在计算机界，也有一个类似的大端小端之争，但是并没有像小人国那般，原先我们虽然在纠结选大端还是小端存储？但是随着计算机的发展，历史告诉我们，这些都是合理的，但是要在计算机间合理通信或者理解计算机底层的时候，你自己记得转换就好了。</p><h1 id="大端和小端存储"><a href="#大端和小端存储" class="headerlink" title="大端和小端存储"></a>大端和小端存储</h1><h2 id="一．概念"><a href="#一．概念" class="headerlink" title="一．概念"></a>一．概念</h2><p>大端：指低字节存储在高地址。<br>小端：指低字节存储在低地址。</p><p><strong>记忆方法：</strong></p><table><td bgcolor=#FFFF FF>小端说：我就是个低低（弟弟）</td></table><p>下图描述了——大端存储（低字节存储在内存高地址了）：<br> <img src="/photos/2020.5.29/1.png" width="80%"></p><p>下图描述了——小端存储（低字节存储在内存低地址了）：：<br> <img src="/photos/2020.5.29/2.png" width="80%"></p><h2 id="二．具体的，大端法和小端法的应用"><a href="#二．具体的，大端法和小端法的应用" class="headerlink" title="二．具体的，大端法和小端法的应用"></a>二．具体的，大端法和小端法的应用</h2><p>有的产品用的大端法，有的产品则是小端法。<br>PS:这个大端和小端并没有严格按照企业界限来区分，因为有的企业，它在之前采用的处理器，可能是大端，但是后面的产品中改变了采用的处理器，可能就采用小端法了。<br>前沿：许多比较新的微处理器使用双端法，也就是说可以把它们配置成作为大端或者小端的机器运行。</p><h2 id="三．大端法和小端法导致的问题："><a href="#三．大端法和小端法导致的问题：" class="headerlink" title="三．大端法和小端法导致的问题："></a>三．大端法和小端法导致的问题：</h2><h3 id="1）网络应用程序数据传输"><a href="#1）网络应用程序数据传输" class="headerlink" title="1）网络应用程序数据传输"></a>1）网络应用程序数据传输</h3><p>在采用不同大小端存储的机器之间通过网络传送二进制数据时候，会导致采用不同大小端存储方式的数据的字节变成反序。<br>解决方案：网络应用程序的代码编写，必须遵循已建立的关于字节顺序的规则（第一处：网络传输规定了，网络字节序(它采用的大端)）。<br>第2处，你的机器发送报文前，需要将你的内部表达转换成网络标准。<br>第3处，你的机器接受报文时候，需要根据你的机器，将网络标准转换为你的内部表示。。</p><p>网络字节序<br>网络上传输的数据都是字节流,对于一个多字节数值，在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;<br>UDP/TCP/IP协议规定:<br>把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;</p><p>而在发送端发送数据时，发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);<br>由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;所以说,网络字节序是大端字节序;</p><p>比如,我们经过网络发送整型数值0x12345678时,在80x86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数将其转换成大端法存放的数值;</p><p>常见CPU的宇节序<br>大端（big Endian）: PowerPC、IBM、 Sun<br>小端（little Endian）:x86、DEC<br>ARM既可以工作在大端模式,也可以工作在小端模式。</p><h3 id="2）反汇编的时候"><a href="#2）反汇编的时候" class="headerlink" title="2）反汇编的时候"></a>2）反汇编的时候</h3><table><tr><td bgcolor=#FFFF FF>（——————未完待续）</td></tr></table><h2 id="四．如何判别大端和小端"><a href="#四．如何判别大端和小端" class="headerlink" title="四．如何判别大端和小端"></a>四．如何判别大端和小端</h2><p>1）我们可以根据C语言中的，联合体来判断，该系统是大端还是小端。<br>因为，联合体变量总是从低地址存储。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">union</span> test    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">;</span>        <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>demo<span class="token punctuation">;</span>    demo<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">0x01ffff03</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x03</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这个机器是小端存储！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这个机器是大端存储！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"无法判断机器类型！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>显然，<br>要是小端存储，那么（低字节）0x03在低地址，<br>要是大端存储，那么（高字节）0x00在低地址。<br>所以，打印出3就是小端存储。打印出0那就是大端存储。<br>笔者的电脑是采用的intel的X86CPU，是小端存储。<br>  <img src="/photos/2020.5.29/3.png" width="80%"></p>]]></content>
      
      
      <categories>
          
          <category> 记忆法 </category>
          
          <category> 编译器底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言优先级和结合性记忆</title>
      <link href="/2020/05/28/test/"/>
      <url>/2020/05/28/test/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言优先级和结合性记忆"><a href="#C语言优先级和结合性记忆" class="headerlink" title="C语言优先级和结合性记忆"></a>C语言优先级和结合性记忆</h1><p><strong>前述</strong>：以前以为，记忆C语言的优先级和结合性就像孔乙己记忆“回”字的四种写法一样有些没必要，对于技术，简洁即美。但以下场景，记忆C语言的优先级结合性还是有一定好处<br><strong>场景</strong>：</p><blockquote><ul><li>记忆一些特定的优先级和结合性，能够帮助从编译器角度来快速识别多级指针和数组指针和函数指针判定指针类型。</li><li>某些项目的遗留代码中有一些编程风格不好的片段，总是不写括号，遇到就需要查书，对研究别人代码，有一定影响。记忆优先级和结合性，能够降低开发中重构已有代码的难度。</li><li>有的相关试题中，有考优先级的题目的存在。(考优先级不是目的，而是为了解决那些风格不好的遗留代码)</li><li>由于编译器语法分析阶段的设计原理，其他语言的优先级也可以在此基础上记忆。<blockquote><ul><li>C语言的优先级，再添加上一些C++本身的运算符，则很容易转换到记忆C++的优先级</li><li>Java的运算符的优先级和C语言相似</li></ul></blockquote></li></ul></blockquote><p><strong><center>优先级从高到低，分为15级</center></strong><br><img src="/photos/2020.5.28/2020_5.28_1.jpg" width="80%"><br><img src="/photos/2020.5.28/2020_5.28_2.jpg" width="80%"></p><h2 id="优先级记忆"><a href="#优先级记忆" class="headerlink" title="优先级记忆"></a>优先级记忆</h2><table><td bgcolor=#FFFF FF>初-单-算-移-关        （出箪蒜一罐）</td></table>  <table><td bgcolor=#FFFF FF>位-逻-三-赋-逗        （味落三伏豆）</td></table> <p>//箪—意指古代盛饭用的圆形竹器</p><blockquote><p>记忆场景：<br>每年三伏天农作时期，要为田间劳作者送饭，送饭者专门用箪盛着食物前往，还专门为其中一个很喜欢吃大蒜的劳作者带了一罐蒜解馋。后来，劳作者吃着发现，今年的三伏天的黄豆也格外美味。</p></blockquote><p>解释：<br>初：初级运算符<br>单：单目运算符<br>算：算数运算符（包含2个优先级）<br>移：移位运算符<br>关：关系运算符（包含2个优先级）</p><p>位：位运算（除去，位运算中的单目运算符~ 包含3个优先级）<br>逻：逻辑运算符（包含2个优先级）<br>三：三目运算符<br>赋：赋值运算符<br>逗：逗号运算符</p><h2 id="结合性记忆"><a href="#结合性记忆" class="headerlink" title="结合性记忆"></a>结合性记忆</h2><table><td bgcolor=#FFFF FF>单三赋    从右左</td></table> <p>除以上规则以外,还有一点。<br>标准的C语言编译器对运算符的解析遵循“最大贪婪”规则。</p><h2 id="“最大贪婪”规则"><a href="#“最大贪婪”规则" class="headerlink" title="“最大贪婪”规则"></a><strong>“最大贪婪”规则</strong></h2><p>当C语言编译器对源程序进行词法分析时，如果运算符的下一个符号还是运算符，并且能和前一个运算符构成一个新的合法运算符时，编译器的词法分析器必须将其解析为两个运算符符号构成的新的运算符。</p><p>举一个没太大实际意义的例子来辅证，例如: x=z+++y;<br>是按照x=z+(++y);来计算，还是按照x=(z++)+y;来计算呢?<br>根据C编译器的“最大贪婪”规则,是按照x=(z++)+y;来计算，而不是按照x=z+(++y)来计算<br>可以验证</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> z<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span>x<span class="token operator">=</span>z<span class="token operator">++</span><span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出结果为8，而不是9</span><span class="token comment" spellcheck="true">//考点：C编译器的“最大贪婪”规则</span></code></pre><h2 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h2><ul><li><p>记忆第一优先级中的和第二优先级</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个数组指针，指向的类型是int (*)[3]</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个指针数组，里面的是int *类型的指针</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个二级指针，指向的类型是int *</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这是一个函数指针，指向的类型是int (*)(int,int)</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这是一个返回值为指针的函数</span></code></pre></li><li><p>比格基地笔试题</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//以下程序的k最终值是：</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>k <span class="token operator">*</span><span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//答:90</span><span class="token comment" spellcheck="true">//解释  =是赋值运算符 *=是赋值运算符  +是算数运算符 </span><span class="token comment" spellcheck="true">//“出箪蒜一罐,味落三伏豆”知，算数运算符优先级高，先算i+j</span><span class="token comment" spellcheck="true">//考点：编程语言的优先级</span></code></pre></li><li><p>360公司笔试题</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> m<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>  <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token operator">=</span><span class="token operator">&amp;</span>m<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//“出箪蒜一罐,味落三伏豆”知,关系运算符==的优先级比赋值运算符=高，知i=0</span>  i<span class="token operator">=</span>p<span class="token operator">==</span><span class="token operator">&amp;</span>m<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//(-*p)中，-和*都是单目运算符，结合性是“单三赋，从右左”，所以，相当于(-n)</span>  j<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%d,j=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出为 i=0,j=7</span><span class="token comment" spellcheck="true">//考点：编程语言的优先级,结合性</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 记忆法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数暴力到欧拉筛法</title>
      <link href="/2020/05/28/hello-world/"/>
      <url>/2020/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="素数相关算法详解"><a href="#素数相关算法详解" class="headerlink" title="素数相关算法详解"></a>素数相关算法详解</h1><p>本文讲解了<strong>素数</strong> 的定义<br>并且从素数的暴力算法一路优化到了欧拉筛法</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><blockquote><ul><li>1.<a href="#jump010">素数的定义</a></li><li>2.<strong>素数相关算法</strong><blockquote><ul><li><a href="#jump021">判别素数的朴素法（暴力法）</a><blockquote><ul><li>算法原理</li><li>实现(轻微优化)</li></ul></blockquote></li><li><a href="#jump022">埃塞托尼亚筛</a><blockquote><ul><li>算法原理</li><li>实现1</li><li>实现2：对实现1的优化</li></ul></blockquote></li><li><a href="#jump023">欧拉筛</a><blockquote><ul><li>算法原理</li><li>实现 </li></ul></blockquote></li></ul></blockquote></li><li>3.==总结==</li></ul></blockquote><h2 id="1-素数的定义"><a href="#1-素数的定义" class="headerlink" title="1.素数的定义"></a>1.素数的定义</h2><p>维基百科定义：<br><strong>质数</strong>（Prime number），又称<strong>素数</strong><br><strong>指在大于1的自然数中</strong>，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。大于1的自然数若不是素数，则称之为<strong>合数</strong>（也称为<strong>合成数</strong>）。<br> <strong>Tips：</strong><br>1.有的教材上：（指在大于1的自然数中）这一点没有强调，导致容易误解！！！<br>也是经常弄晕一些人对素数的理解的原因。<br>2.所以：<table><tr><td bgcolor=#FFFF FF>1既不是素数也不是合数！！！</td></tr></table></p><h2 id="2-素数相关算法"><a href="#2-素数相关算法" class="headerlink" title="2.素数相关算法"></a>2.素数相关算法</h2><h3 id="判别素数的朴素法（暴力法）"><a href="#判别素数的朴素法（暴力法）" class="headerlink" title="判别素数的朴素法（暴力法）"></a>判别素数的朴素法（暴力法）</h3><span id="jump021"></span><h5 id="1）算法原理："><a href="#1）算法原理：" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>不管三七二十一<br>根据素数定义就是一顿暴力。</p><h5 id="2）实现-轻微优化"><a href="#2）实现-轻微优化" class="headerlink" title="2）实现(轻微优化)"></a>2）实现(轻微优化)</h5><h6 id="代码段："><a href="#代码段：" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//0表示不是素数，1表示是素数 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//表示根号n向下取整 </span>    <span class="token keyword">int</span> sqrt_num<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>sqrt_num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是素数 </span><span class="token punctuation">}</span></code></pre><h3 id="埃塞托尼亚筛"><a href="#埃塞托尼亚筛" class="headerlink" title="埃塞托尼亚筛"></a>埃塞托尼亚筛</h3><span id="jump022"></span><h5 id="1）算法原理：-1"><a href="#1）算法原理：-1" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>1&gt;假设从2-N全是素数<br>2&gt;从2开始枚举，对于每个素数，我们筛去它的所有倍数，最后我们剩下来的就都是素数<br><strong>关键点</strong>：<br>从2开始枚举到某个数字A，如果a没有被前面步骤的数筛去，那么a一定是素数。<br>原因：<br><strong>如果A(A&gt;2)是合数</strong>，则<strong>A=素数×另一个数</strong><br><strong>PS：这个素数必定小于A，所以会被我们前面筛出来的素数筛掉</strong></p><h5 id="2）实现"><a href="#2）实现" class="headerlink" title="2）实现"></a>2）实现</h5><p>用一个标记数组实现<br>枚举的过程中，筛的过程就是依次改变这个标记数组的过程</p><h5 id="实现1：按照思路直接筛，筛的过程如下图红色箭头所示"><a href="#实现1：按照思路直接筛，筛的过程如下图红色箭头所示" class="headerlink" title="实现1：按照思路直接筛，筛的过程如下图红色箭头所示"></a>实现1：按照思路直接筛，筛的过程如下图红色箭头所示</h5><img src="/photos/2020.5.28/2020_5.26_1.png" width="80%"><h6 id="代码段：-1"><a href="#代码段：-1" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Eratosthenes_one.cpp </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数i，并且Num+1</span>            <span class="token comment" spellcheck="true">//注意这种写法，本来应该用i*j&lt;=(maxn-1)判断就好了</span>            <span class="token comment" spellcheck="true">//但是要避免i*j的结果溢出int,所以改为j&lt;=((maxn-1)/i)</span>            <span class="token comment" spellcheck="true">//maxn-1是因为标记数组范围本来就只有0-100004 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                TagArray<span class="token punctuation">[</span>j<span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//筛去素数i的倍数 </span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+4中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="实现2："><a href="#实现2：" class="headerlink" title="实现2："></a>实现2：</h5><p>在实现1的基础上，我们发现，如图中蓝色部分的，被重复筛了。我们容易观察出，如果要减少筛的次数，我们可以从质数的平方往后筛（优化）<br><img src="/photos/2020.5.28/2020_5.26_2.png" width="80%"></p><h6 id="代码段：-2"><a href="#代码段：-2" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Eratosthenes_two.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数i，并且Num+1</span>            <span class="token comment" spellcheck="true">//注意这种写法，本来应该用i*j&lt;=(maxn-1)判断就好了</span>            <span class="token comment" spellcheck="true">//但是要避免i*j的结果溢出int,所以改为j&lt;=((maxn-1)/i)</span>            <span class="token comment" spellcheck="true">//maxn-1是因为标记数组范围本来就只有0-100004 </span>            <span class="token comment" spellcheck="true">//(修改处)将j=2改为了j=i，这样就能少筛掉表格中那些蓝色部分了 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                TagArray<span class="token punctuation">[</span>j<span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//筛去素数i的倍数 </span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+4中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><span id="jump023"></span><p><strong>由来</strong>：<br>由于埃塞托尼亚筛筛的时候重复筛（比如下面的）了，使得算法效率还不够好，所以，我们改进一下，我们继续观察先前的图，发现埃塞托尼亚筛是<strong>竖着筛</strong>，我们似乎也难以优化这种筛法了，我们转换一下思路——<strong>横着筛</strong></p><h5 id="1）算法原理：-2"><a href="#1）算法原理：-2" class="headerlink" title="1）算法原理："></a>1）算法原理：</h5><p>思路：在埃氏筛的一种优化<br>任何合数都能写成一个素数乘一个数（显然这个素数不一定是唯一的）<br>//举个例子：12=2<em>6=3</em>4（2和3都是素数）<br>所以，任何合数都有一个<strong>最小的质因数</strong></p><table><tr><td bgcolor=#FFFF FF>用这个"最小质因数"来判断什么时候不用继续筛下去</td></tr></table><p>那么如何实现呢？<br>欧拉研究发现，我要是<strong>横着筛</strong>就会比前面那种只优化掉蓝色部分的埃氏筛还快</p><img src="/photos/2020.5.28/2020_5.26_3.png" width="80%"><p><strong>注意</strong>：这里是横着筛，此外图中箭头从<strong>橙色出发（包括该点）</strong>往右的所有我都不筛<br>具体实现方法是用的一个<strong>break</strong>实现的。</p><h5 id="2）实现-1"><a href="#2）实现-1" class="headerlink" title="2）实现"></a>2）实现</h5><h6 id="代码段：-3"><a href="#代码段：-3" class="headerlink" title="代码段："></a>代码段：</h6><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//Euler.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//除了0,1之外(因为0和1既不是合数，也不是素数)</span><span class="token comment" spellcheck="true">//TagArray数组中，0表示i是素数，1表示是合数</span><span class="token keyword">int</span> TagArray<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Prime数组中存放素数(从0号位开始放)</span><span class="token comment" spellcheck="true">//Num表示Prime数组中素数的个数 </span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span><span class="token number">10000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>maxn<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>TagArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果标记数组说i这个数是素数 </span>        <span class="token punctuation">{</span>            Prime<span class="token punctuation">[</span>Num<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存素数，并且Num+1    </span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>Num<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxn<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//一进来,不管三七二十一，先筛掉一个先</span>            TagArray<span class="token punctuation">[</span>i<span class="token operator">*</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>Prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//判别i是Prime数组中某个的倍数，则跳出，</span>                <span class="token comment" spellcheck="true">//这行后面的也不用筛     </span>                <span class="token keyword">break</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>              <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//求1-100000+5-1中哪些是素数</span>    <span class="token function">FindPrime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正整数100004内素数的个数:%d\n"</span><span class="token punctuation">,</span>Num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>Prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
